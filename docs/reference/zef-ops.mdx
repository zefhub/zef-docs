---
id: zef-ops
title: ZefOps
author: bot
---


Autogenerated for version 0.15.7.

# ZefOps
### ApplyFunctions
```python
Given a list of values and an associated list of functions,
apply the nth function to the nth value list element.

It is strongly recommended not to use impure functions inside
this operator.

---- Examples ----
>>> ['Hello', 'World'] | apply_functions[to_upper_case, to_lower_case]    # => ['HELLO', 'world']
>>> (1,2) | apply_functions[add[1], add[10]]      # => (2, 12)

---- Signature ----
(Tuple[T1, ...,TN], Tuple[T1->TT1, ..., TN->TTN] ) -> Tuple[TT1, ...,TTN]

---- Tags ----
- used for: control flow
- operates on: ZefOp
- operates on: Function
- related zefop: reverse_args
- related zefop: map
- related zefop: apply
```

### Map
```python
Apply a pure function elementwise to each item of a collection.
It can be used both for iterables and streams (observables).

Note: It is strongly recommended not to use impure functions 
(with side effects, i.e. that change any state of the program)
inside "map". You may be looking for "for_each" or "tap" in that 
case.    

---- Examples -----
>>> [3, 4, 5] | map[add[1]]                      # => [4, 5, 6]
>>> [1, 2, 3] | map[str, add[100]]               # => [('1', 101), ('2', 102), ('3', 103)]

---- Signature ----
(List[T1], (T1 -> T2))  -> List[T2]

---- Tags ----
- used for: control flow
- used for: function application
- related zefop: apply_functions
- related zefop: apply
```

### MapCat
```python
Returns the flatten results of f applied to each item of x. Equivalent to:
`x | map[f] | concat`.

---- Examples ----
>>> [1,0,3] | flat_map[lambda x: x | repeat[x]]  # => [1, 3, 3, 3]
>>> [z1,z2] | flat_map[Outs[RT]]             # All outgoing relations on z1 and z2.

---- Signature ----
(Iterable, Function) => List
```

### Reduce
```python
None
```

### Scan
```python
An operator that take a list of values together with an initial state 
an emits a sequence of resulting states.
Similar to 'reduce', but also emits all previous states if required.

This implies "scan[f][state_ini] | last = reduce[f][state_ini]".

Equivalent to Python's builtin 'accumulate', but named differently
to be consistent with ReactiveX and the nomenclature in the 
live data streaming community.

This is also called 'scan' in reactiveX and Scala, 'scanl' in 
Haskell and accumulate in python itertools. Similar to reduce, 
but returns a sequence with each intermediate result. Essentially 
this is the operator equivalent to event sourcing or the state model 
in React/Redux and Elm.

Note: On the very first call s='a' and el='b' are used

---- Examples ----
>>> ['a', 'b', 'c', 'd', 'e'] | scan[lambda s, el: s+el]    
>>> # => [    'a', 'ab', 'abc', 'abcd', 'abcde']

---- Signature ----    
(List[T1], ((T2, T1)->T2), T2)  ->  List[T2]
```

### GroupBy
```python
categories is optional and specifies additional keys/categories 
to create, even if there are no occurrences. The categories can
be implicitly inferred from the data or explicitly specified 
(useful for dispatch and allowing for empty catergories).

---- Examples ----
>>> range(10) | group_by[modulo[3]]   # => [(0, [0, 3, 6, 9]), (1, [1, 4, 7]), (2, [2, 5, 8])]

---- Tags ----
- used for: control flow
- operates on: List
- operates on: Stream
- related zefop: group
```

### Group
```python
Examine successive elements in a List and return 
a lazy list of lists: the given function f maps 
the elements within each sublist map onto the 
same value, i.e. the splitting occurs where mapped
elements differ.

---- Examples ----
>>> ['a','a','a','b','b','c','a', 'a'] | group      # => [('a', 'a', 'a'), ('b', 'b'), ('c',), ('a', 'a')]
>>> [2,4,6,1,3,2,5,7,9,10] | group[lambda x: x%2]   # => [(2, 4, 6), (1, 3), (2,), (5, 7, 9), (10,)]

---- Signature ----
(List[T], (T)->T2) -> List[List[T]]

---- Tags ----
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
- related zefop: group_by
- related zefop: chunk
```

### Transpose
```python
This operator is essentially the operation of transposition on a matrix
that is infinite along one direction (vertical (m) for the 
input matrix in normal A_(m,n) nomenclature).
It is different from "interleave" in that it produces a List of Lists,
whereas "interleave" flattens it out into one List.

Note that transposing is its own inverse: transposing twice leads to the
original List, if the operation succeeds.

---- Examples ----
>>> [ [2,3,4], [5,6,7] ]                    # => [ [2, 5], [3,6], [4,7] ]
 
>>> # terminates upon the shortest one:
>>> [ range(2, infinity), [5,6], [15,16,17] ]    # => [[2, 5, 15], [3, 6, 16]]

---- Tags ----
- used for: list manipulation
- used for: linear algebra
- same naming as: C++ Ranges V3
```

### Frequencies
```python
None
```

### Iterate
```python
for a homomorphism f and initial val x: [x, f(x), f(f(x)), ...].
Inspired by the excellent talk by Joel Grus on functional Python.

---- Examples ----
>>> 42 | iterate[lambda x: x+1]                                         # => [42, 43, 44, ...]
>>> 
>>> # find all of Joe's friends on a graph up to third degree
>>> ([z_joe, ] 
>>>   | iterate[lambda z: z >> L[RT.FriendOf] | concat | distinct]      # flatten out and remove duplicates
>>>   | take[3]
>>> )


---- Signature ----
(T, (T->T)) -> List[T]
```

### Identity
```python
The identity function: always returns the input argument

---- Examples ----
>>> 42 | identity     # => 42

---- Tags ----
operates on: Any
used for: function composition
```

### Length
```python
Zef's version of the length function.
Similar to Python's `len` and sometimes
called `count` in other languages.

---- Examples ----
>>> ['a', 'b', 'c'] | length     # => 3

---- Signature ----
(List[T]) -> Int

---- Tags ----
related zefop: count
operates on: List
operates on: Stream
```

### Take
```python
positive n: take n first items. Operates lazily and supports infinite iterators.
negative n: take n last items. Must evaluate entire iterable, does not terminate 
for infinite iterables.


---- Signature ----
(List[T], Int) -> List[T]
```

### TakeWhile
```python
None
```

### TakeWhilePair
```python
use when termination of sequence depends on two successive elements.
Generates items until the predicate function returns false for the first time.
Emits both elements given to the predicate function upon the last call.

---- Examples ----
>>> (2 
>>>   | ops.iterate[lambda n: n+1 if n < 10 else 10] 
>>>   | take_while_pair[lambda m,n: m!=n]    
>>>   ) # =>   [2, 3, 4, 5, 6, 7, 8, 9, 10]

---- Signature ----
(List[T], ((T*T)->Bool)) -> List[T]
```

### TakeUntil
```python
Similar to take_while, but with negated predicate and 
it includes the bounding element. Useful in some cases,
but take_while is more common.

---- Examples ----
>>> range(10) | take_until[lambda x: x>4] | collect       # => [0, 1, 2, 3, 4, 5]

---- Signature ----
(List[T], (T->Bool)) -> List[T]
```

### SkipWhile
```python
None
```

### Skip
```python
Skip the first n elements of the sequence. 
This can be done lazily.

For negative n the counting is done from the back.
This cannot be done lazily: one needs to know when the 
list / iterator / stream ends before emitting the 
first element.

---- Examples ----
>>> range(10) | skip[3]                         # => [3,4,5,6,7,8,9]
>>> ['a', 'b', 'c', 'd'] | skip[-2]             # => ['a', 'b']

---- Signature ----
(List[T], Int) -> List[T]
```

### Nth
```python
Returns the nth element of an iterable or a stream.
Using negative 'n' takes from the back with 'nth[-1]' 
being the last element. An Error value is returned if 
the index is out of bounds.
This is sometimes called 'get` in other languages, but
we want to distinguish it from key lookup.
Note: this uses a zero-indexed convention.

---- Examples ----
>>>['a', 'b', 'c', 'd'] | nth[1]       # => 'b'
>>>['a', 'b', 'c', 'd'] | nth[-2]      # => 'c'
>>>['a', 'b', 'c', 'd'] | nth[10]      # => Error['nth: index out of range using']

---- Arguments ----
iterable: a List[T] / LazyValue[List[T]] / Awaitable[List[T]]
n (Int): a non-negative integer specifying the index of the element to return.

----- Signature ----
(List[T], Int) -> Union[T, Error]
(LazyValue[List[T]], Int) -> LazyValue[Union[T, Error]]
(Awaitable[List[T]], Int) -> Awaitable[Union[T, Error]]    
```

### Filter
```python
Filters an iterable or stream lazily.

---- Examples ----
>>> [1,2,3,4,5] | filter[lambda x: x%2 == 0]       # => [2, 4]
>>> [1,2,3,4,5] | filter[greater_than[2]]          # => [3, 4, 5]

---- Arguments ----
itr: a List[T] / LazyValue[List[T]] / Awaitable[List[T]]
pred (Func[(T,), Bool]): a predicate function

----- Signature ----
(List[T], (T->Bool)) -> List[T]

---- Tags ----
- used for: control flow
- operates on: List
```

### SelectKeys
```python
Given a dictionary, return a new dictionary containing 
the same key value pairs, but for a specified subset of
keys only.

Based on Clojure's select-keys 
https://clojuredocs.org/clojure.core/select-keys

---- Examples ----
>>> {'a': 3, 'b': 2, 'c': 1} | select_keys['a']['f']      # => {'a': 3}

----- Signature ----
(Dict[T1, T2], T1, ...) -> Dict[T1, T2]

---- Tags ----
- operates on: Dict
- related zefop: filter
- related zefop: get
- related zefop: get_in
- related zefop: merge
```

### Modulo
```python
The modulo function.

---- Examples ----
>>> 12 | mod[10]       # => 2

----- Signature ----
(Int, Int) -> Int

---- Tags ----
- operates on: Int
- topic: Maths
```

### SelectByField
```python
An optimized equivalent of calling:
zrs | filter[Z >> O[rt] | value_or[None] | equals[val]]
although the case of val=None is not permitted.

This is implemented in C++. In the future when the native version is as
fast, this will deprecated.

----- Signature ----
(List[ZefRef], RelationType, Any) -> List[ZefRef]

---- Tags ----
- operates on: Graph
- related zefop: filter
- related zefop: value    
```

### Without
```python
Returns the piped iterable without any items that are contained in the
argument. As a special case, dictionaries are returned without any keys
contained in the argument.

Note the syntax of `| without[1]` is not supported. The argument must be an
iterable.

Note that the type of the output is determined by the following operators,
e.g. `{1,2,3} | without[x] | collect` will return a list, even though the
input is a set.

---- Examples ----
>>> [1,2,3] | without[[2]]            # => [1,3]
>>> {'a', 5, 10} | without['abc']     # => [10, 5]
>>> {'a': 1, 'b': 2} | without[['a']] # => {'b': 2}

---- Signature ----
(Iterable, Iterable) => List
(Dict, Iterable) => Dict
```

### First
```python
Return the first element of a list.

---- Examples ----
>>> [1,2,3] | first          # => 1
>>> [] | first               # => Error

---- Signature ----
List[T] -> Union[T, Error]
```

### Second
```python
Return the second element of a list.

---- Examples ----
>>> [1,2,3] | second          # => 2
>>> [1,] | second             # => Error

---- Signature ----
List[T] -> Union[T, Error]
```

### Last
```python
Return the last element of a list.

---- Examples ----
>>> [1,2,3] | first          # => 3
>>> [] | first               # => Error

---- Signature ----
List[T] -> Union[T, Error]
```

### Single
```python
Return the element from a list containing a single element only.

---- Examples ----
>>> [42,] | single          # => 42
>>> [42, 43] | single       # => Error

---- Signature ----
List[T] -> Union[T, Error]
```

### SingleOr
```python
Given an iterable which should contain either 0 or 1 elements and a default, return the element if it exists, otherwise return the default. Lists that are 2 or more elements long cause an Error

---- Examples ----
>>> [42] | single_or[None]          # => 42
>>> [] | single_or[None]            # => None
>>> [42, 43] | single_or[None]      # => Error

---- Signature ----
List[T],T2 -> Union[T, T2, Error]
```

### Zip
```python
can be used with allputs piped in via one tuple, 
or other Lists to zip withbeing curried in.

---- Examples ----
>>> (('a', 'b', 'c', 'd'), range(10)) | zip                  # => [('a', 0), ('b', 1), ('c', 2), ('d', 3)]
>>> range(10) | zip['a', 'b', 'c', 'd']                      # => [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
>>> range(10) | zip['a', 'b', 'c', 'd'][True,False,True]     # => [(0, 'a', True), (1, 'b', False), (2, 'c', True)]
>>> (('a', 'b', 'c', 'd'), range(10)) | zip | zip            # => [('a', 'b', 'c', 'd'), (0, 1, 2, 3)]
```

### Concat
```python
Concatenate a list of lists (or streams).
Can also be used to specify other lists to be concatenated as
additional args curried in.

---- Examples ----
>>> # A) all passed in via a List of Lists (no args curried into concat op)
>>> [
...     [1,2,3],                                    
...     ['a', 'b', 'c', 'd'],
... ] | concat                                      
[1, 2, 3, 'a', 'b', 'c', 'd']
 
>>> # B) One list piped in, other lists to concatenated curried into op
>>> [1,2,3] | concat[ (42,43) ][('a','b','c')]      # =>  [1, 2, 3, 42, 43, 'a', 'b', 'c']

---- Signature ----
(List[T1], List[T2], ...)        -> List[T1 | T2 | ...]
(Stream[T1], Stream[T2], ...)    -> Stream[T1 | T2 | ...]
(String, String, ...)            -> String

---- Tags ----
- operates on: List
- operates on: Stream
- operates on: String
- related zefop: interleave
- related zefop: interleave_longest
- related zefop: merge
- related zefop: append
- related zefop: prepend
- used for: list manipulation
- used for: stream manipulation
- used for: string manipulation
```

### Prepend
```python
Prepend an element to a list / observable.    
Special overload for strings as well.

---- Examples ----
>>> ['b', 'c'] | prepend['a']           # => ['a', 'b', 'c']
>>> 'morning' | prepend['good ']        # => 'good morning'

---- Signature ----
(List[T1], T2)    -> List[T1 | T2]
(Stream[T1], T2)  -> Stream[T1 | T2]
(String, String)  -> String

---- Tags ----
- operates on: List
- operates on: Stream
- operates on: String
- related zefop: append
- related zefop: insert_at
- used for: list manipulation
- used for: string manipulation
```

### Append
```python
Append an element to a list / observable.    
Special overload for strings as well.

---- Examples ----
>>> ['b', 'c'] | append['d']           # => ['b', 'c', 'd']
>>> 'good' | append[' evening']        # => 'good evening'

---- Signature ----
(List[T1], T2)    -> List[T1 | T2]
(Stream[T1], T2)  -> Stream[T1 | T2]
(String, String)  -> String

---- Tags ----
- operates on: List
- operates on: Stream
- operates on: String
- related zefop: prepend
- related zefop: insert_at
- used for: list manipulation
- used for: string manipulation
```

### Interleave
```python
Interleaves elements of an arbitrary number M of lists.
Length of output is determined by the length of the 
shortest input list N_shortest: M*N_shortest

---- Examples ----
>>> # Either called with a list of of lists (or equivalent for streams)
>>> [
...    [1,2,3],
...    ['a', 'b', 'c', 'd']        
... ] | interleave          
[1, 'a', 2, 'b', 3, 'c']
>>> 
>>> # or with other lists to interleave with being curried in
>>> [1,2,3] | interleave[42 | repeat]       # => [1, 42, 2, 42, 3, 42]
>>> [1,2,3] | interleave[42 | repeat][('a','b')]      # => [1, 42, 'a', 2, 42, 'b']

---- Signature ----
List[List[T]] -> List[T]

---- Tags ----
- related zefop: interleave_longest
- related zefop: concat
- related zefop: merge
- operates on: List
- same naming as: C++ Ranges V3
```

### InterleaveLongest
```python
Interleaves elements of an arbitrary number M of lists.
Length of output is determined by the length of the 
longest input list

---- Examples ----
>>> # Either called with a list of of lists (or equivalent for streams)
>>> [
>>>     [1,2,3],
>>>     ['a', 'b', 'c', 'd']        
>>> ] | interleave_longest          # =>  [1, 'a', 2, 'b', 3, 'c', 'd']
>>> 
>>> # or with other lists to interleave with being curried in
>>> [1,2,3] | interleave_longest[[42]*5]        # => [1, 42, 2, 42, 3, 42, 42, 42]
>>> [1,2,3] | interleave_longest[[42]*5][('a','b')]      # => [1, 42, 'a', 2, 42, 'b', 3, 42, 42, 42]

---- Signature ----
List[List[T]] -> List[T]

---- Tags ----
- related zefop: interleave_longest
- related zefop: concat
- related zefop: merge
- operates on: List
```

### Sort
```python
An optional key function for sorting may be provided, e.g.
list_of_strs | sort[len]

---- Signature ----
List[T] -> List[T]
(List[T], (T->T2)) -> List[T]       # T2 orderable
```

### Now
```python
Caution: impure!

The 'now' operator provides the link between the physical 
time at which the computation is executed and the "time"
that is part of the inherent data that is operated on and
that is also often saved as data on graphs.

It can be used in a variety of contexts:
a)  As a nullary function (i.e. calling it without arguments) 
    returns the current physical time.
b)  As a transformational operator that changes the reference 
    frame to the currently executing process, i.e. the thread
    performing the computation at the very time this operation 
    is called.

It is impure, since calling it at different physical times will
give different outputs.
Impurity is transitive: any function calling it is also impure.

---- Examples ----
now()                                   # returns current time (of type Time) 
g | now                                 # latest graph slice
gs | now                                # latest graph slice
z_zr_my_entity | now                    # ZefRef -> ZefRef:     fast forward to very latest reference frame at time of execution
z_ezr_my_entity | now                   # EZefRef -> ZefRef:    fast forward to very latest reference frame at time of execution
z_ezr_my_entity[allow_tombstone] | now  # EZefRef -> ZefRef:    flag allows representing RAEs that were terminated.

---- Signature ----
() -> Time
Graph -> GraphSlice
GraphSlice -> GraphSlice
ZefRef -> ZefRef
EZefRef -> ZefRef
(ZefRef, ZefOp) -> ZefRef
(EZefRef, ZefOp) -> ZefRef
```

### Events
```python
Given a TX as a (E)ZefRef, return all events that occurred in that TX.
Given a ZefRef to a RAE, return all the events that happend on the RAE.

- filter_on allows for filtering on the type of the events; by default it is none which
returns all events.

---- Examples ----
>>> z_tx  | events                          => [instantiated[z1], terminated[z3], assigned[z8][41][42] ]


---- Signature ----
ZefRef[TX] | EZefRef[TX]  ->  List[ZefOp[Union[Instantiated[ZefRef], Terminated[ZefRef], ValueAssigned[ZefRef, Any, Any]]]]

---- Tags ----
- related zefop: preceding_events
- related zefop: instantiation_txs
- related zefop: termination_txs
- related zefop: assignment_txs
```

### PrecedingEvents
```python
Given a TX as a (E)ZefRef, return all events that occurred in that TX.
Given a ZefRef to a RAE, return all the events that happend on the RAE.

- filter_on allows for filtering on the type of the events; by default it is none which
returns all events.

---- Examples ----
>>> my_graph_slice | events                  => [instantiated[z1], terminated[z3], assigned[z8][41][42] ]
>>> z_rae | events                          => [instantiated[z1], assigned[z8][41][42], terminated[z3]]
>>> z_rae | events[Instantiated]            => [instantiated[z1]]
>>> z_rae | events[Instantiated | Assigned] => [instantiated[z1], assigned[z8][41][42]]

---- Signature ----
Union[ZefRef[TX], EZefRef[TX]]  ->  List[ZefOp[Union[Instantiated[ZefRef], Terminated[ZefRef], ValueAssigned[ZefRef, T]]]]
```

### ToDelegate
```python
None
```

### DelegateOf
```python
None
```

### In
```python
Traverse along a unique Incoming relation to the
thing attached to the source of that relation.
If there is no or multiple incoming relations, 
it will return an Error.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | In[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRef | Error
EZefRef -> EZefRef | Error
```

### Ins
```python
Traverse along all incoming relation of the specified 
type to the thing attached to the source of each relation.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | Ins[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRefs
EZefRef -> EZefRefs
```

### Out
```python
Traverse along a unique outgoing relation to the
thing attached to the target of that relation.
If there is no or multiple outgoing relations, 
it will return an Error.
This function can also be used by specifying logical
subtypes. The edge type `rt` to traverse on can 
be seen as the type to filter the instances of
outgoing edges on, i.e. as special case of pattern 
matching.

The default value for `rt` is VT.Any, i.e. no filtering
on the relation type is performed and it is assumed
that a single outgoing relation of any type exists.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | Out[RT.FriendOf]
>>> z1s_friend = z1 | Out     

---- Signature ----
ZefRef -> ZefRef | Error
EZefRef -> EZefRef | Error
```

### Outs
```python
Traverse along all outgoing relation of the specified 
type to the thing attached to the target of each relation.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | Outs[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRefs
EZefRef -> EZefRefs
```

### InRel
```python
Traverse onto a unique incoming relation of the specified 
type and return the relation (it does NOT proceed to the source).
In case of no or multiple incoming relations of 
the specified type, it will return an Error.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | in_rel[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRef | Error
EZefRef -> EZefRef | Error
```

### InRels
```python
Traverse onto all incoming relations of the specified 
type and return the relations (it does NOT proceed 
to the sources).

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friends = z1 | in_rels[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRefs
EZefRef -> EZefRefs
```

### OutRel
```python
Traverse onto a unique outgoing relation of the specified 
type and return the relation (*NOT* the target).
In case of no or multiple outgoing relations of 
the specified type, it will return an Error.

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friend = z1 | out_rel[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRef | Error
EZefRef -> EZefRef | Error
```

### OutRels
```python
Traverse onto all outgoing relations of the specified 
type and return the relations (it does NOT proceed 
to the targets).

For a ZefRef, it will always stay in the same time
slice of the given graph.

When Used on an EZefRef, the eternal graph is traversed.

---- Examples ----
>>> z1s_friends = z1 | out_rels[RT.FriendOf]

---- Signature ----
ZefRef -> ZefRefs
EZefRef -> EZefRefs
```

### InOld
```python
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
```

### InInOld
```python
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
```

### OutOld
```python
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
```

### OutOutOld
```python
partial(func, *args, **keywords) - new function with partial application
of the given arguments and keywords.
```

### Source
```python
None
```

### Target
```python
None
```

### Value
```python
None
```

### Time
```python
Return the time of the object.

---- Signature ----
ZefRef[TX]  -> Time
EZefRef[TX] -> Time
GraphSlice  -> Time
```

### TimeSlice
```python
Returns the time slice as an special `TimeSlice` object for a given  GraphSlice.

Note: we may introduce z_tx | time_slice if we can find a convincing use case.
We're leaving it out for now, since this builds on the prior confusion
of identifying transactions themselves with time slice.
The new mental image is that reference frames are somewhat distinct from 
TXs and a time slice applies to a reference frame, not a TX directly.

---- Examples ----
>>> my_graph_slice | time_slice

---- Signature ----
GraphSlice -> TimeSlice
```

### NextTX
```python
Given a ZefRef/EZefRef to a tx, move to the next tx.
For a ZefRef with a reference frame, one cannot look 
into the future, i.e. get to a TX that was not known 
in that reference frame. Nil is returned in that case.

For Both ZeFfRef/EZefRef, Nil is returned when called
on the very latest TX.

---- Examples ----
z2_tx = z_tx | next_tx | collect

---- Signature ----
ZefRef -> Union[ZefRef, Nil]
EZefRef -> Union[EZefRef, Nil]

---- Tags ----
- used for: time traversal
- related zefop: previous_tx
- related zefop: time_travel
```

### PreviousTX
```python
Given a ZefRef/EZefRef to a tx, move to the previous tx.
If one tries to go back from the very first tx, nil is 
returned.    

---- Examples ----
z2_tx = z_tx | previous_tx | collect

---- Signature ----
ZefRef -> Union[ZefRef, Nil]
EZefRef -> Union[EZefRef, Nil]

---- Tags ----
- used for: time traversal
- related zefop: previous_tx
- related zefop: time_travel
```

### InstantiationTx
```python
None
```

### TerminationTx
```python
None
```

### Uid
```python
None
```

### Frame
```python
Extract the reference frame (subject) of a ZefRef.
Return as a GraphSlice.

---- Examples ----
>>> z_tx_zr | frame        # returns the subject (not object pointed to!) / reference frame as a GraphSlice
>>> z_et | frame           # returns the reference frame (GraphSlice)
>>> z_aet | frame          # returns the reference frame (GraphSlice)
>>> z_rt | frame           # returns the reference frame (GraphSlice)

---- Signature ----
ZefRef -> GraphSlice
```

### DiscardFrame
```python
Given any kind of reference referring to a RAE,
it returns the frame-independent representation.

---- Signature ----
ZefRef[ET[T1]] -> Entity[T1]
ZefRef[AET[T1]] -> AtomicEntity[T1]
ZefRef[RT[T1]] -> Relation[T1]
ZefRef[BT.TX] -> TX           # TODO
ZefRef[BT.Root] -> Graph      # TODO

EZefRef[ET[T1]] -> Entity[T1]
EZefRef[AET[T1]] -> AtomicEntity[T1]
EZefRef[RT[T1]] -> Relation[T1]
EZefRef[BT.TX] -> TX          # TODO
EZefRef[BT.Root] -> Graph     # TODO

Entity[T1] -> Entity[T1]
AtomicEntity[T1] -> AtomicEntity[T1]
Relation[T1] -> Relation[T1]

---- Tags ----
```

### BaseUid
```python
None
```

### OriginUid
```python
used in constructing GraphDelta, could be useful elsewhere
```

### OriginRAE
```python
For RAEs, return an abstract entity, relation or atomic entity. For delegates, acts as the identity.
```

### ExistsAt
```python
None
```

### AwareOf
```python
Return whether the Graph is aware of the object `z` in the frame given. This
differs from exists_at in that a graph is still "aware" of a terminated
entity, and low-level blobs are also valid inputs to aware_of.

---- Signature ----
((ZefRef | EZefRef), GraphSlice) -> Bool
```

### IsZefRefPromotable
```python
None
```

### InFrame
```python
Represent a RAE in a specified reference frame.
No changes are made to the graph and an error is returned if the operation is not possible,

 - optional arguments: in_frame[allow_tombstone]

---- Examples ----
>>> z | in_frame[my_graph_slice]                    # z: ZefRef changes the reference frame, also if z itself points to a tx
>>> z | in_frame[allow_tombstone][my_graph_slice]   # allow can opt in to represent RAEs that were terminated in a future state

---- Signature ----
(ZefRef, GraphSlice)        -> Union[ZefRef, Error]
(EZefRef[TRAE], GraphSlice) -> Union[ZefRef, Error]    
```

### ToGraphSlice
```python
Return the object (tx pointed to by a ZefRef[TX]) as a GraphSlice.
Works for ZefRef[TX] and EZefRef[TX] as well as (Graph, Time) pairs in both orders.
z_tx_zr | to_graph_slice           # ZefRef  -> GraphSlice,     discards reference frame, returns a GraphSlice
z_tx_ezr | to_graph_slice          # EZefRef -> GraphSlice      returns a GraphSlice

---- Examples ----
>>> t1: Time = now()
>>> g | to_graph_slice[t1]
>>> t1 | to_graph_slice[g]
```

### ToTx
```python
Given a GraphSlice (reference frame), return a ZefRef[TX] to the 
transaction that led to this state.
The ZefRef has the same transaction as object and subject (ref frame).

---- Examples ----
>>> my_graph_slice | to_tx     # => ZefRef[TX]

---- Signature ----
GraphSlice    -> ZefRef[TX]
(Graph, Time) -> ZefRef[TX]
```

### TimeTravel
```python
Move the reference frame in time only.
The temporal movement can absolute: p is a Time
or relative: p is a Int (move this number of graph slices) or a duration
i.e. the eternal graph of the reference frame
remains contant.    

---- Examples ----
>>> #       ---- relative time travel ----
>>> zr | time_travel[-3]                    # how many time slices to move
... zr | time_travel[-3.5*units.seconds]  
... my_graph_slice | time_travel[-3]
 
>>> #       ---- time travel to fixed time ----
>>> t1 = Time('October 20 2020 14:00 (+0100)')
... g | time_travel[t1]
... gs | time_travel[t1]
... ezr | time_travel[t1]
... zr | time_travel[t1]
... ezr | time_travel[allow_tombstone][t1]
... zr | time_travel[allow_tombstone][-3]
... zr | time_travel[allow_tombstone][-3.5*units.seconds]
... zr | time_travel[allow_tombstone][t1]

---- Signature ----
(ZefRef, Int)                           -> Union[ZefRef, Nil]           # nil or error? What is the process / criterion?
(ZefRef, Duration)                      -> Union[ZefRef, Nil]
(GraphSlice, Int)                       -> Union[GraphSlice, Nil]
(GraphSlice, Duration)                  -> Union[GraphSlice, Nil]

(ZefRef, Time)                          -> Union[ZefRef, Nil]
(EZefRef, Time)                         -> Union[ZefRef, Nil]
(Graph, Time)                           -> Union[GraphSlice, Nil]
(GraphSlice, Time)                      -> Union[GraphSlice, Nil]

---- Tags ----
- used for: time traversal
- related zefop: time_slice    
- related zefop: next_tx
- related zefop: previous_tx
- related zefop: time
```

### ToEZefRef
```python
None
```

### O
```python
O[...]  is "optional", meaning it will return either 0,1 results.
If the RT.Edge  exists it'll traverse that and return a ZefRef
If the RT.Edge  doesn't exist, it'll return None or nothing .
If there are multiple RT.Edge  it'll throw an error

---- Examples ----
>>> z1 >> O[RT.Foo]        # of type {ZefRef, None, Error}
```

### L
```python
None
```

### Terminate
```python
None
```

### Assign
```python
None
```

### ET
```python
None
```

### RT
```python
None
```

### AET
```python
None
```

### BT
```python
None
```

### FillOrAttach
```python
None
```

### SetField
```python
None
```

### Assert
```python
None
```

### HasOut
```python
None
```

### HasIn
```python
None
```

### Run
```python
None
```

### Tap
```python
An operator mostly used for debugging and testing
purposes: allows inserting an impure function into
a pipeline.
In contrast to apply/map it is not the output of
provided function which is forwarded, but the original 
input. It is therefore ever only of any use to
insert an impure function into tap, since the return 
value is discarded.

---- Examples ----
>>> 41 | add[1] | tap[print] | multiply[2] | collect    # prints 42 and the expression returns 84

---- Tags ----
- used for: debugging
- related zefop: apply
```

### Push
```python
A pure operator that constructs an effect (a value)
to push an element into a pushable stream.

---- Examples ----
>>> {'msg': 'hello'} | push[my_pushable_stream]                     # returns an effect
>>> my_msg_stream | subscribe[push[my_pushable_stream]]             # messages are transformed into Effects and executed upon arrival
>>>
>>> # upcoming functionality
>>> my_effect | push[z_process]         # wraps an effect as a task effect that will be routed and potentially executed on the specified process
>>> my_effect | push[zefhub]

---- Signature ----
(T, Stream) -> Effect
```

### IsA
```python
    
```

### IsRepresentedAs
```python
None
```

### RepresentationType
```python
Warning: this function is not complete and its behavior may change!!!!!!!!!!!

Returns a Zef ValueType_ (a value itself),
also when used with the python builtin supported
types, as well as with instances of Zef Values.

TODO:
my_ent | representation_type   # Entity[ET.Foo]
z | representation_type        # ZefRef[ET.Foo]
ez| representation_type        # EZefRef[ET.Foo]

ET.Foo | representation_type    # ET
ET     | representation_type    # ValueType
```

### HasRelation
```python
None
```

### Relation
```python
None
```

### Relations
```python
None
```

### Chunk
```python
This one is tricky. We'll be opinionated and eagerly evaluate the 
elements in each chunk, as the chunks are being asked for. The 
chunks are returned as a generator.

If the input is an iterable (could be infinite generator or not), 
this returns a generator of generators. An operator downstream could 
choose to evaluate the terms of a later iterator before those of an 
earlier one emitted here. If we can't access via ...[], we have to
iteratively step through.

Be opinionated here: instead of going full in with checking whether 
the iterable has random access ...[n] semantics (C++ has the more 
detailed model built in for this), we'll perform caching.    

Perform caching and store the evaluated values in case these are 
to be accessed by the earlier iterable. Keep them up to the point
until the earlier iterable has consumed them, then discard them.

---- Examples ----
>>> range(8) | chunk[3]          # => [[0, 1, 2], [3, 4, 5], [6, 7]]
>>> 'abcdefgh' | chunk_imp[3]    # => ['abc', 'def', 'gh']

---- Signature ----
(List[T], Int)   -> List[List[T]]
(Stream[T], Int) -> Stream[Stream[T]]
(String, Int)   -> List[String]

---- Tags ----
operates on: List
operates on: String
operates on: Stream
used for: list manipulation
used for: string manipulation
used for: stream manipulation
related zefop: stride
related zefop: sliding
related zefop: slice
```

### Sliding
```python
Given a list, return a list of internal lists of length "window_size".
"stride_step" may be specified (optional) and determines how
many elements are taken forward in each step.
Default stride_step if not specified otherwise: 1.

implementation follows Scala's, see https://stackoverflow.com/questions/32874419/scala-slidingn-n-vs-groupedn

---- Examples ----
>>> range(5) | sliding[3]       # [(0, 1, 2), (1, 2, 3), (2, 3, 4)]
>>> range(5) | sliding[3][2]    # [(0, 1, 2), (2, 3, 4)]

---- Signature ----
(List[T], Int, Int) -> List[List[T]]

---- Tags ----
- related zefop: stride
- related zefop: chunk
- related zefop: slice
- operates on: List
```

### Stride
```python
Return a new list where only every nth 
(specified by the stride step) is sampled.

---- Examples ----
>>> Range(8) | stride[3]     #  [0, 3, 6]

---- Signature ----
(List[T], Int) -> List[T]

---- Tags ----
operates on: List
operates on: String
operates on: Stream
used for: list manipulation
used for: string manipulation
used for: stream manipulation
related zefop: chunk
related zefop: sliding
related zefop: slice
```

### Insert
```python
Takes a dictionary / flatgraph together with something to insert
and returns a new dictionary / flatgraph with that inserted.
The input values are not mutated or harmed during this operation.


---- Examples ----
>>> {'a': 1} | insert['b'][2]   ->  {'a': 1, 'b': 2} 
>>> FlatGraph() | insert[ET.God, RT.Favorite, Val(1/137)] | insert[ET.BigBang]

---- Signature ----
(Dict[T1][T2], T1, T2) -> Dict[T1][T2]

---- Tags ----
- level: easy
- used for: control flow
- operates on: Dict
- operates on: FlatGraph
- related zefop: insert_in
- related zefop: remove
- related zefop: update
```

### InsertInto
```python
For Dicts:
Given a dictionary as a curried in argument and the key 
value pair as the data flow argument, return a new dictionary
with the inserted value.

For Lists:
the dataflow argument is a tuple (pos, val), where
val will be inserted into the given list at position pos.    
For Lists this operator is equivalent to insert_at,
but with the argument oder flipped.

This function could also be used on Lists. 

---- Examples ----
>>> (2, 'a') | insert_into[ range(4) ]    # [0,1,'a',2,3]

---- Signature ----
((T1, T2), Dict[T3][T4]) -> Dict[T1|T3][T2|T4]

---- Tags ----
- level: advanced
- operates on: Dict
- operates on: List
- related zefop: insert
- related zefop: insert_at
- related zefop: merge
- related zefop: apply_functions

# TODO: make this work: (10, 'a') | insert_into[range(10) | map[add[100]]] | take[5] | c
```

### ReverseArgs
```python
Useful to transform one zefop into a new operator where
the only difference is that the arguments are reversed.
This applies when we want an operator where the dataflow 
is determined by a different argument than the usual one.

Suppose we want to have the op 'insert_into', which is a
slight variation of "insert":
('my_key': 42) | insert_into[{'a':1}]

With this operator, we can construct "insert_into" on the fly:
>>> insert_into = reverse_args[insert]

---- Examples ----
>>> ('my_key': 42) | reverse_args[insert][{'a':1}]      # {'my_key': 42, 'a': 1}
>>> 'x' |  reverse_args[get][{'a':1, 'x': 42}]          # 42

---- Signature ----
(T1, ZefOp[T..., T1][T2], T...) -> T2

---- Tags ----
- level: advanced
- used for: control flow
- operates on: ZefOp
- operates on: Function
- related zefop: func
- related zefop: apply_functions
```

### Remove
```python
Given a key and a dictionary, returns a new dictionary 
with the key value pair removed.

This operator is NOT overloaded for Lists, since this
could be confused with the mutating Python method on
lists: my_list.remove(2) removes the first occurrence
of the VALUE "2" and not at the location.
Use "remove_at" for lists.

---- Examples ----
>>> {'a': 1, 'b', 2} | remove['a']   ->  {'b': 2}

---- Tags ----
- operates on: Dict
- related zefop: remote_at
- related zefop: remote_in
- related zefop: insert
- related zefop: get
```

### Get
```python
Typically used for key lookups, equivalent to '[]' operator.
External function equivalent to Python's '__get__' method.
Default values can be provided

---- Examples ----
>>> {'a': 42, 'b': 'hello'} | get['a']                    # => 42
>>> {'a': 42, 'b': 'hello'} | get['a']                    # => 42

----- Signature ----
(Dict[T1, T2], T1) -> T2
(Graph, T1) -> Any
(FlatGraph, T1) -> Any

---- Tags ----
- operates on: Dict
- operates on: Graph
- operates on: FlatGraph
- related zefop: get_in
- related zefop: get_field
- related zefop: insert
- related zefop: remove
- related zefop: select_in
```

### GetField
```python
Specific to python. Get the attribute of an object, equivalent to
getattr(obj, field).

---- Examples ----
# Note: the following example is much better expressed as ET("Machine")
>>> ET | get_field["Machine"]                # => ET.Machine

# Note: the nodes of a NetworkX graph can be accessed via, e.g. list(nxg.nodes)
>>> nxg | get_field["nodes"] | filter[...]

----- Signature ----
(T, String) -> T2

---- Tags ----
- related zefop: get
- operates on: Python objects
```

### Enumerate
```python
Given an iterable, returns an iterable of pairs where 
the first is an incrementing integer starting at zero.

---- Examples ----
>>> ['a', 'b', 'c'] | enumerate     # [(1, 'a'), (2, 'b'), (3, 'c')]

---- Signature ----
List[T1] -> List[Tuple[Int, T1]]
Stream[T1] -> Stream[Tuple[Int, T1]]
String -> List[Tuple[Int, String]]

---- Tags ----
- used for: list manipulation
- used for: string manipulation
- used for: lazy transformation
- operates on: List
```

### Items
```python
Return the key-value pairs of a dictionary as a tuple.

---- Examples ----
>>> {'a': 100, 42: 'die antwoord', 'c': True} | values           # ( ('a', 100), (42, 'die antwoord'), ('c', True) )

---- Signature ----
Dict[T1][T2] -> List[Tuple[T1, T2]]

---- Tags ----
- used for: dict manipulation
- used for: list manipulation
- operates on: Dict
```

### Values
```python
Return the values of a dictionary

---- Examples ----
>>> {'a': 100, 42: 'die antwoord', 'c': True} | values           # (100, 'die antwoord', True)

---- Signature ----
Dict[T1][T2] -> List[T2]

---- Tags ----
- used for: dict manipulation
- operates on: Dict
```

### Keys
```python
Return the keys of a dictionary

---- Examples ----
>>> {'a': 100, 42: 'die antwoord', 'c': True} | keys           # ('a', 42, 'c')

---- Signature ----
Dict[T1][T2] -> List[T1]

---- Tags ----
- used for: dict manipulation
- operates on: Dict
```

### Reverse
```python
Reverse a list or equivalent structure.

---- Examples ----
>>> [2,3,4] | reverse           # [4,3,2]
>>> 'straw' | reverse           # 'warts'

---- Signature ----
List[T1] -> List[T1]
Stream[T1] -> Stream[T1]
String -> String

---- Tags ----
- used for: list manipulation
- used for: stream manipulation
- operates on: List
```

### RaeType
```python
None
```

### AbstractType
```python
None
```

### Root
```python
Retrieve the root node for a Graph or Graph Slice.

---- Examples ----
>>> g | root
>>> g | now | root

---- Signature ----
Graph -> EZefRef
GraphSlice -> ZefRef

---- Tags ----
- used for: graph traversal
```

### Blueprint
```python
WARNING: the name/interface of this zefop is not stable and is likely to change in the future.

Returns all delegate nodes on the graph or alive in the given GraphSlice.
These are the delegate entities/relations which reference all instances on
the graph.

The optional argument `include_edges` can be set to True to also return the
low-level edges between these nodes, which is useful for plotting with
`graphviz`.

---- Examples ----
>>> g | blueprint[True] | graphviz          # Shows the blueprint of graph g.
>>> g | now | blueprint[True] | graphviz    # Shows the blueprint of graph g in the current time slice.

>>> # A blank graph already has one TX delegate node.
>>> g = Graph()
... g | blueprint | collect
[<EZefRef #65 DELEGATE TX at slice=0>]

---- Signature ----
(Graph, Bool) => List[EZefRef]
(GraphSlice, Bool) => List[ZefRef]
```

### Z
```python
None
```

### Docstring
```python
Return the docstring for a given ZefOp or Zef Function.
    
---- Examples ----
>>> docstring(nth)
```

### SourceCode
```python
Return the function body for a given ZefOp or Zef Function.
    
---- Examples ----
>>> source_code(insert_at) | to_clipboard | run
```

### GetIn
```python
Enable one-shot access to elements in nested dictionary
by specifying path as a tuple of keys.
Based on Clojure's 'get-in'.

---- Examples ----
>>> {'a': 1, 'b': {'c': 1}} | get_in[('b', 'c')]   # => 1
>>> {'a': 1, 'b': {'c': 1}} | get_in[('b', 'wrong_key')][42]   # => 42

---- Tags ----
- related zefop: get
- related zefop: remove_in
- related zefop: update_in
- related zefop: insert_in
- related zefop: get_in
- operates on: Dict
```

### InsertIn
```python
Create a new dicitonary from an old one by inserting one value
for a given nested path.

---- Examples ----
>>> {'a': 1, 'b': {'c': 1}} | insert_in[('b', 'd')][42]   # => {'a': 1, 'b': {'c': 1, 'd': 42}} 

---- Tags ----
- related zefop: insert
- related zefop: get_in
- related zefop: remove_in
- related zefop: update_in
- operates on: Dict
```

### Update
```python
Change the value for a given key / index by applying a
user provided function to the old value at that location.

Note: the equivalent ZefOp to use on Lists is "update_at"
(to be consistent with "remove_at" for Lists and 
disambiguate acting on the value)

---- Examples ----
>>> {'a': 5, 'b': 6} | update['a'][add[10]]   # => {'a': 15, 'b': 6}

---- Tags ----
- related zefop: update_at
- related zefop: update_in
- related zefop: get
- related zefop: insert
- operates on: Dict
- used for: control flow
- used for: function application
```

### UpdateIn
```python
Given a dictionary, a tuple describing a path into
the dictionary and an update function, 
this returns a new dictionary with the element point to
replaced with the value obtained by applying the update 
function to the previous element.
The original dictionary is not mutated.

---- Examples ----
>>> {'a': 1, 'b': {'c': 1}} | update_in[('b', 'c')][add[1]]   # => {'a': 1, 'b': {'c': 2}} 

---- Signature ----
(Dict, List, T1->T2) -> Dict

---- Tags ----
- related zefop: update
- related zefop: update_at
- related zefop: insert_in
- related zefop: remove_in
- related zefop: get_in
- operates on: Dict
- used for: control flow
- used for: function application
```

### UpdateAt
```python
Apply a specified function "f" to a specified position of 
a list using the existing element "el" as function input.
A new list is returned which differs only in that element
which is replaced with "f(el)".
When called with negative index n, this is interpreted as
reverse indexing with -1 referring to the last element.

---- Examples ----
>>> [5,6,7] | update_at[2][add[10]]   # => [5,6,17]

---- Signature ----
(List[T1], T1->T2) -> List[T1|T2]

---- Tags ----
- related zefop: update
- related zefop: update_in
- related zefop: remove_at
- related zefop: replace_at
- operates on: List
- used for: control flow
- used for: function application
```

### InsertAt
```python
Insert a specified value at a specified position of 
a list. A new list is returned, the input list is not mutated.
When called with negative index n, this is interpreted as
reverse indexing with -1 referring to the last element.

---- Examples ----
>>> [0,1,2] | insert_at[1]['hello']   # => [0,'hello',1,2]

---- Signature ----
(List[T1], T1->T2) -> List[T1|T2]
(List[T1], T2) -> List[T1|T2]

---- Tags ----
- related zefop: insert
- related zefop: insert_in
- related zefop: update_at
- related zefop: remove_at
- related zefop: replace_at
- operates on: List
- operates on: Stream
- operates on: String
- used for: list manipulation
- used for: stream manipulation
- used for: string manipulation
```

### RemoveIn
```python
Given a dictionary and a tuple describing a path into the dictionary,
this returns a new dictionary with the pointed to value removed.
The original dictionary is not mutated.

---- Examples ----
>>> {'a': 1, 'b': {'c': 1}} | remove_in[('b', 'c')]   # => {'a': 1, 'b': {}}

---- Signature ----
(Dict[T1][T2], List) -> Dict[T1][T2]

---- Tags ----
- related zefop: remove
- related zefop: remove_in
- related zefop: remove_at
- related zefop: update_in
- related zefop: insert_in
- related zefop: get_in
- operates on: Dict
- used for: control flow
- used for: function application
```

### RemoveAt
```python
Using "remove" based on indexes would be confusing,
as Python's list remove, searches for the first 
occurrence of that value and removes it.

---- Examples ----
>>> ['a', 'b', 'c'] | remove_at[1]       # => ['a', 'c']
>>> ['a', 'b', 'c'] | remove_at[1][0]    # => ['c']

---- Signature ----
List[T] & Length[Z] -> List[T] & Length[Z-1]

---- Tags ----
- related zefop: interleave_longest
- related zefop: concat
- related zefop: merge
- operates on: List
```

### Merge
```python
Merge a dictionaries: either one list of dicts or
dicts as multiple args.

Clojure has a similar operator:
https://clojuredocs.org/clojure.core/merge

---- Examples -----
>>> [{'a': 1, 'b': 42}, {'a': 2, 'c': 43}] | merge          # => {'a': 2, 'b': 42, 'c': 43}
>>> {'a': 1, 'b': 42} | merge[ {'a': 2, 'c': 43} ]

---- Signature ----
List[Dict]          -> Dict
(Dict, Dict)        -> Dict
(Dict, Dict, Dict)  -> Dict

---- Tags ----
- operates on: Dict
- related zefop: merge_with
```

### MergeWith
```python
Merge a list of maps, but give an operation to join the values 
for matching keys.
The function provided for the merging must be able to operate on
the value type in the dictionary (it suffices if it works for the
value type of the matching keys only).

Based on the Clojure operator https://clojuredocs.org/clojure.core/merge-with

---- Examples ----
>>> {'a': 1, 'b': 2} | merge_with[add][{'a': 3}]                        # => {'a': 4, 'b': 2}
>>> {'a': 1, 'b': 2} | merge_with[add][{'a': 3}, {'b': 10, 'c': 5}]     # => {'a': 4, 'b': 12, 'c': 5}    
>>> [{'a': [1], 'b': [2]}, {'a': [3]}] | merge_with[concat]             # => {'a': [1, 2], 'b': [3]}

---- Signature ----
(Dict[T1, T2], ((T2,T2)->T2), Dict[T1, T2]) -> Dict[T1, T2]
(List[Dict[T1, T2]], ((T2,T2)->T2)) -> Dict[T1, T2]
```

### IntToAlpha
```python
Map an integer n to the nth letter of the alphabet.
Always lower case.

---- Examples ----
>>> 3 | int_to_alpha    # => 'c'

---- Tags ----
- operates on: Int
- used for: string manipulation
```

### PermuteTo
```python
given a input list, as well as a list of indices, 
return the list of elements arranged according to the 
list of indices.

>>> ['a', 'b', 'c', 'd'] | permute_to[2,0,1]    # => ['c', 'a', 'b']

---- Tags ----
- operates on: List
- used for: list manipulation
```

### Cycle
```python
Given a list, this wll produce another list loft the same structure
that cycles thorugh all elements of the original list n times.

---- Examples ----
>>> [2,3] | cycle[3]  # => [2,3,2,3,2,3]
>>> [2,3] | cycle     # => [2,3,2,3,2,3,...    # never terminates

---- Signature ----
(List[T], Int) -> List[T]

---- Tags ----
- used for: list manipulation
- used for: stream manipulation
- operates on: List
```

### Repeat
```python
Repeat an element a given number of times 
None (default) means infinite).

---- Examples ----
>>> 42 | repeat[3]    # => [42,42,42]
>>> (1,'a') | repeat  # => [(1,'a'), (1,'a'), ...]    # infinite sequence

---- Tags ----
- related zefop: cycle
- operates on: Any
```

### Contains
```python
Check whether an element is in a given
set or iterable. Operator for of Python's
`in`.

---- Examples ----
>>> {42, 43} | contains[42]         # => 42
>>> g | contains[my_entity_ref]     # => 

---- Tags ----
- related zefop: contained_in
- operates on: List
- operates on: Set
- operates on: Dict
- operates on: Graph
- operates on: FlatGraph
```

### ContainedIn
```python
None
```

### All
```python
The all op has two different behaviours:

A) The first is to "find all of" for a graph-like or graph-slice-like
object. Of a GraphSlice/FlatGraph, this will return a ZefRef list of every RAE, and of a
Graph this will return a EZefRef list of every blob.

An optional argument can be a type that provides a filter on the kind of
items returned. It should always be true that: `g | all[Type]` is equivalent
to `g | all | filter[is_a[Type]]` however providing the Type to `all` can be
much more efficient.

B) The second behaviour is to test the truth of every element in a list. It
is similar to the builtin `all` function of python. If the list is empty,
returns True.

---- Examples ----
>>> g | now | all[ET]       # all entities in the latest timeslice of the graph

>>> g | all[TX]             # all transaction blobs in the graph

>>> [True,True] | all   # => True
>>> [False,True] | all  # => False
>>> [] | all            # => True

Test whether all ZefRefs have an RT.Name relation.
>>> zrs | map[has_out[RT.Name] | all

---- Signature ----
List[T] -> Bool
GraphSliceLike -> List[ZefRef]
GraphLike -> List[EZefRef]
(GraphSliceLike, Type) -> List[ZefRef]
(GraphLike, Type) -> List[EZefRef]

---- Tags ----
- used for: predicate
```

### Any
```python
Given a list of booleans: check whether any of them are true.
Equivalent to the logical 'or' in propositional logic.
Also equivalent to Python's builtin 'any', but pipeable and
applicable to Streams.

An empty list will return False.

---- Examples ----
>>> [False, True, False] | any                 # => True

>>> [False, False, False] | any                # => False

>>> [] | any                                   # => False
```

### Join
```python
Join a list of strings with a binding character.

---- Examples ----
>>> ['foo', 'bar'] | join['-']              # => 'foo-bar'

---- Signature ----    
(List[String], String) -> String

---- Tags ----
- related zefop: concat
- related zefop: insert_at
- operates on: String
```

### Trim
```python
Removes all contiguous occurrences of a specified 
element / character from both sides of a list / string.

---- Examples ----
>>> '..hello..' | trim['.']            # => ['..hello']

---- Signature ----
(List[T], T) -> List[T]
(String, String) -> String

---- Tags ----
- related zefop: trim_left
- related zefop: trim_right
- related zefop: split
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
```

### TrimLeft
```python
Removes all contiguous occurrences of a specified 
element / character from the left side of a list / string.

---- Examples ----
>>> '..hello..' | trim_left['.']            # => ['hello..']

---- Signature ----
(List[T], T) -> List[T]
(String, String) -> String

---- Tags ----
- related zefop: trim
- related zefop: trim_right
- related zefop: split
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
```

### TrimRight
```python
Removes all contiguous occurrences of a specified 
element / character from the right side of a list / string.

---- Examples ----
>>> '..hello..' | trim_right['.']            # => ['..hello']

---- Signature ----
(List[T], T) -> List[T]
(String, String) -> String

---- Tags ----
- related zefop: trim
- related zefop: trim_left
- related zefop: split
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
```

### Yo
```python
None
```

### Sign
```python
Utility function that returns the sign of a number (+1/-1).
also: sign(0)=0

---- Signature ----
Union[Int, Float] -> SetOf[-1,0,1] | Error
```

### Attempt
```python
Wrap an operator to catch errors. If anything goes wrong,
return the user provided alternative value.

---- Examples ----
>>> risky_chain = (
>>>     map[lambda x: 1/x] 
>>>   | filter[greater_than[0]] 
>>>   | single
>>> )
>>> alternative_val = 42
>>> 
>>> [-1,10,-3] | attempt[risky_chain][alternative_val]     # => 0.1
>>> [-1,10,3] | attempt[risky_chain][alternative_val]      # => 42      (single called on list with 2 items)
>>> [-1,0,-3] | attempt[risky_chain][alternative_val]      # => 42      (division by zero)

---- Signature ----
(T, (T-> Union[T1, Error]), T2) -> Union[T1, T2]

---- Tags ----
- used for: control flow
- related zefop: if_then_else
- related zefop: expect
- related zefop: ensure
- related zefop: bypass
```

### Bypass
```python
specify one or a tuple of types that will be bypassed. Otherwise the specified 
function will be called and the result returned.

---- Examples ----
>>> my_stream | bypass[Error][my_func]        # any Error will just be forwarded
>>> my_stream | bypass[Error, Int][my_func]
>>> my_stream | bypass[set_of[_1 < 42]][my_func]

---- Signature ----
(List[T, T2], Type(T2), (T -> T3)) -> List[Union[T2, T3]]

---- Tags ----
used for: control flow
operates on: ZefOp
```

### Pattern
```python
generates a predicate function given a parameterized pattern for
dicts or list.
It is often used inside the "match" operator.

---- Examples ----
>>> [1,2,3,4,5] | pattern[_any, 2, _any, 4]               # => True
>>> [1,2,3,4,5] | pattern[_any, 2, _any, 5]               # => False
>>> 
>>> {'a': 1, 'b': 2} | pattern[{'a': Z}]                  # => True: is there any key a?
>>> {'a': 1, 'b': 2} | pattern[{'a': Z, 'b': 2}]          # => True

---- Signature ----
(List[T], List[Union[T, _Any]]) -> Bool
(Dict[T1, T2], Dict[Union[T1, _Any], Union[T2, _Any]]) -> Bool

---- Tags ----
- operates on: List
- operates on: Dict
- used for: control flow
- related zefop: match
- related zefop: match_apply
- related zefop: distinct_by
```

### Replace
```python
Replace any specified old value with a new value in a List.

---- Examples ----
>>> ['a', 'b', 'c', 'd'] | replace['b'][42]    # ['a', 42, 'c', 'd'] 
>>> 'the zen of python' | replace['n']['f']    # 'the zef of pythof'

---- Signature ----
List[T1], T1, T2 -> List[T1 | T2]
Char = String & Length[1]
String, Char, Char -> String

---- Tags ----
- operates on: String
- operates on: List
- used for: list manipulation
- used for: string manipulation
- related zefop: replace_at
- related zefop: insert_in
- related zefop: insert
- related zefop: remove
```

### Distinct
```python
Remove multiple occurrences of the same element (determined 
via == comparison evaluating to True). Do this lazily, such 
that this can also be applied to lazily.

---- Examples ----
>>> [4,5,4,1,5,4] | distinct        # => [4, 5, 1]

---- Arguments ----
v: an iterable with elements that can be compared

---- Signature ----
List[T] -> List[T]
LazyValue[List[T]] -> LazyValue[List[T]]

---- Tags ----
- operates on: Stream
- operates on: List
- used for: list manipulation
- related zefop: is_distinct
- related zefop: distinct_by
```

### DistinctBy
```python
Remove multiple occurrences of the same element determining equality
after passing through the function passed in.    
Do this lazily, such that this can also be applied to lazily.

---- Examples ----
>>> [-1,2,1,-2] | distinct_by[lambda x: x*x]        # => [-1, 2]

---- Arguments ----
v: an iterable with elements that can be compared
comparison_function: (T, T) -> Bool

---- Signature ----
(List[T], (T->Any)) -> List[T]
LazyValue[(List[T], (T->Any))] -> LazyValue[List[T]]

---- Tags ----
- operates on: List
- operates on: Stream
- used for: list manipulation
- related zefop: is_distinct_by
- related zefop: distinct
```

### IsDistinct
```python
Used on an iterable / stream of values and
returns a boolean indicating whether all
values are distinct. i.e. as soon as any value
appears more than once, False is returned.

---- Examples ----
>>> [1,2,3] | is_distinct        # => True
>>> [1,2,3,2] | is_distinct      # => False

---- Arguments ----
v: an iterable with elements that can be compared

---- Signature ----
List[T] -> Bool
Stream[T] -> Bool
LazyValue[List[T]] -> Bool

---- Tags ----
- operates on: String
- operates on: List
- used for: set theory
- related zefop: is_distinct_by
- related zefop: distinct
```

### IsDistinctBy
```python
Very similar to `is_distinct` zefop, but takes a user
provided function `fn` to compare the equality testing with.

---- Examples ----
>>> [1,2] | is_distinct_by[lambda x: x%2]      # => True
>>> [1,2,3] | is_distinct_by[lambda x: x%2]    # => False

---- Arguments ----
v: an iterable with elements that can be compared
fn: the function to be applied elementwise

---- Signature ----
List[T], Callable -> Bool
Stream[T], Callable -> Bool

---- Tags ----
- operates on: String
- operates on: List
- used for: set theory
- related zefop: distinct_by
- related zefop: is_distinct
```

### Shuffle
```python
Shuffles the elements in a list. If a seed is
provided, this is a pure function.
If no seed is set to None, the system's 
RNG is used to draw one. In this case this
operation is impure!


TODO: implement coeffects to get randomness from FX system.

---- Examples ----
>>> ['a', 'b', 'c', 'd'] | shuffle[189237]    # => ['d', 'b', 'a', 'c']

---- Tags ----
- operates on: List
- used for: list manipulation
- used for: randomness
```

### Slice
```python
factor out python-style slicing: ...[5:8].
Negative indexes count from the back.
If three arguments are given from the range, the 
last one denotes the step size.

---- Examples ----
>>> ['a', 'b', 'c', 'd'] | slice[1:2]    # => ['b', 'c']
>>> 'abcdefgh' | slice_imp[1,6,2]        # => 'bdf'

---- Tags ----
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
- related zefop: take
- related zefop: reverse
- related zefop: first
- related zefop: last
- related zefop: nth    
```

### Split
```python
Split a List into a List[List] based on the occurrence of val.
The value that is split on is not contained in any of the output lists.

---- Examples ----
>>> 'abcdeabfb' | split['b']            # => ['a', 'cdea', 'f', '']
>>> [0,1,6,2,3,4,2,] | split[2]         # => [[0, 1, 6], [3, 4], []]    

---- Signature ----
(List[T], T) -> List[List[T]]

---- Tags ----
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
- related zefop: split_left
- related zefop: split_right
- related zefop: split_if
- related zefop: trim
```

### SplitLeft
```python
Split a List into a List[List] based on the occurrence of val.
In contrast to `split`, it adds the element to split on to the
following sublist - i.e. it splits on the left side.

---- Examples ----
>>> 'abcdeabfb' | split_left['b']            # => ['a', 'bcdea', 'bf', 'b']
>>> [0,1,6,2,3,4,2,] | split_left[2]         # => [[0, 1, 6], [2, 3, 4], [2]]    

---- Signature ----
(List[T], T) -> List[List[T]]

---- Tags ----
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
- related zefop: split
- related zefop: split_right
- related zefop: split_if
- related zefop: trim
```

### SplitRight
```python
Split a List into a List[List] based on the occurrence of val.
In contrast to `split`, it adds the element to split on to the
left sublist - i.e. it splits on the right side.

---- Examples ----
>>> 'abcdeabfb' | split_right['b']            # => ['ab', 'cdeab', 'fb']
>>> [0,1,6,2,3,4,2,] | split_right[2]         # => [[0, 1, 6, 2], [3, 4, 2]]    

---- Signature ----
(List[T], T) -> List[List[T]]

---- Tags ----
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
- related zefop: split
- related zefop: split_left
- related zefop: split_if
- related zefop: trim
```

### SplitIf
```python
Similar to split, but the user provides a predicate function 
that determines the positions to split on.

The symbols that are split on, are not included in the result.

---- Examples ----
>>> 'good4morning2to6you' | split_if[is_numeric]    # => ['good', 'morning', 'to', 'you']
>>> range(10) | split_if[lambda x: x % 3 == 0 ]     # => [[], [1, 2], [4, 5], [7, 8], []]

---- Signature ----
(List[T], T->Bool) -> List[List[T]]

---- Tags ----
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
- related zefop: split
- related zefop: concat
- related zefop: trim
- used for: predicate
```

### Graphviz
```python
Returns a GraphViz visualization of the graph passed in.
By default it returns an error if more than 1000 RAEs are to be shown.

Zef graphs are meta-graphs: relations can themselves have outgoing relations
which allows mimicing the behavior of property graphs (with nodes/relations 
allowed to contain "objects" / dictionaries).

GraphViz does not allow plotting relations out of relations (please let us
know if we're wrong here and you know a way!). Therefore we need to 
map the meta-graph onto a larger true graph (each relation becoming a node)
and subsequently plot this. The downside is the visual clarity:
It may be hard to see which edges/lines are the true edges and which lines
are other incoming/outgoing edges to the actual edge.

As a slight improvement, each relation's color is based on it's type: this 
allows identifying the actual relation as the one with and incoming and
outgoing arrow of the same color in case of ambiguity.

---- Examples ----
>>> g | now | all | graph_viz | collect
>>> g | now | all | graph_viz[simplified] | collect     # No extra nodes introduced for relations. Hence: can't show relations out of relations.
>>> g | all | graph_viz | collect                       # show the full eternal graph


---- Signature ----
List[EZefRef] -> Image
List[ZefRef] -> Image
(List[ZefRef], ZefOp) -> Image
```

### Always
```python
Regardless of the input, always return the curried in value.

---- Examples ----
[1,2,3] | map[always[True]]      # => [True, True, True]

match[
    (equals[5], "special case"),
    (always[True], "default")
]

---- Signature ----
(T, T2) -> T2
```

### WithoutAbsorbed
```python
Return the bare Type as if nothing had ever been absorbed.

---- Examples ----
>>> LazyValue(reduce[add[1]][42]) | without_absorbed    # => reduce

---- Tags ----
- used for: control flow
- operates on: ZefOp, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: absorbed
- related zefop: inject
- related zefop: inject_list
- related zefop: reverse_args
```

### Absorbed
```python
Extract the absorbed values from any absorbing type.

---- Examples ----
>>> reduce[add[1]][42] | absorbed    # => (add[1], 42)

---- Tags ----
- used for: control flow
- operates on: ZefOp, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: without_absorbed
- related zefop: inject
- related zefop: inject_list
- related zefop: reverse_args
```

### CartesianProduct
```python
Note that Python's itertools calls this "product only", but 
but that term is too overloaded, e.g. the 'multiply' operator.

---- Examples ----
>>> [1,2,3] | cartesian_product[('a', 'b')]                   # => [ (1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b') ]
>>> [1,2,3] | cartesian_product[('a', 'b')][(True,False)]     # => [ (1, 'a', True), ...
>>> 
>>> or pass in all args:
>>> ([1,2,3], ['a', 'b']) | cartesian_product                 # => [ (1, 'a'), (2, 'a'), (3, 'a'), (1, 'b'), (2, 'b'), (3, 'b') ]

---- Signature ----
List[ List[T1], List[T2] ] -> List[ (T1, T2) ]
(List[T1], List[T2])       -> List[ (T1, T2) ]


---- Tags ----
- operates on: List
- used for: combinatorics
- related zefop: combinations
- related zefop: permutations
```

### Permutations
```python
Given a list of items, return a list of lists with all 
permutations lazily. Order within the returned combination 
does not play a role.

If given, the second argument is the length of each output.

---- Examples ----
>>> ['a', 'b', 'c'] | permutations 
>>> # returns:
>>> # [
>>> #     ['a', 'b', 'c'],
>>> #     ['a', 'c', 'b'],
>>> #     ['b', 'a', 'c'],
>>> #     ['b', 'c', 'a'],
>>> #     ['c', 'a', 'b'],
>>> #     ['c', 'b', 'a']
>>> # ]

>>> [1,2,3] | permutations[2]    # specify the number of elements in each sample
>>> # returns: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

---- Signature ----
List[T] -> List[List[T]]
(List[T], Int) -> List[List[T]]

---- Tags ----
- operates on: List
- used for: combinatorics
- related zefop: combinations
- related zefop: cartesian_product
```

### Combinations
```python
Given a list of m elements, return all combinations
of length n. Order within the returned combination 
does not play a role.

---- Examples ----
[1,2,3] | combinations[2]      # => [(1, 2), (1, 3), (2, 3)]

---- Signature ----
(List[T], Int) -> List[List[T]]
```

### Add
```python
Adds two elements. Neither is a list.
Don't use this when summing up a list, use `sum`
in that case.

---- Examples ----
40 | add[2]    # => 42

---- Signature ----
(T1, T2) -> T1 | T2

---- Tags ----
used for: maths
operates on: Int
operates on: Float
related zefop: sum
related zefop: subtract
related zefop: multiply
related zefop: divide
```

### Sum
```python
Sums up all elements in a List.
Similar to the `add` zefop, but to be used in the case of a 
single argument being passed as a list.
`add` is used when exactly two elements are passed individually.

---- Signature ----
List[T] -> T

---- Tags ----
used for: maths
operates on: List
related zefop: add
related zefop: product
```

### Product
```python
Multiplies up all elements in a List.
Similar to the `multiply` zefop, but to be used in the case of a 
single argument being passed as a list.
`multiply` is used when exactly two elements are passed individually.

---- Signature ----
List[T] -> T

---- Tags ----
used for: maths
operates on: List
related zefop: cartesian_product
related zefop: multiply
related zefop: sum
```

### Subtract
```python
Binary operator to subtract two elements. Neither is a list.
If am operator is needed that can act on a tuple of length 2,
this can be wrapped in `unpack`.

---- Examples ----
44 | subtract[2]               # => 42
(42, 10) | unpack[subtract]    # => 32

---- Signature ----
(T1, T2) -> T1 | T2

---- Tags ----
used for: maths
operates on: Int
operates on: Float
related zefop: add
related zefop: multiply
related zefop: divide
related zefop: unpack
```

### Multiply
```python
Binary operator only. For a list of numbers, use `product`.

---- Examples ----
>>> 2 | multiply[3]    # => 6

---- Signature ----
(Int, Int) - > Int
(Float, Float) - > Float

---- Tags ----
used for: maths
operates on: Int
operates on: Float
related zefop: product
related zefop: add
related zefop: divide
related zefop: subtract
related zefop: unpack
```

### Divide
```python
Binary operator to divide two elements. Neither is a list.
If am operator is needed that can act on a tuple of length 2,
this can be wrapped in `unpack`.

---- Examples ----
10 | divide[2]                # => 5
(10, 2) | divide[subtract]    # => 5

---- Signature ----
(T1, T2) -> Float

---- Tags ----
used for: maths
operates on: Int
operates on: Float
related zefop: add
related zefop: multiply
related zefop: add
related zefop: subtract
related zefop: unpack
```

### Mean
```python
Calculates the arithmetic mean of a given List / Set of numbers.

---- Examples ----
>>> [3,7,20] | mean    # => 10

---- Signature ----
List[Int] -> Float
Set[Int] -> Float
List[Float] -> Float
Set[Float] -> Float

---- Tags ----
used for: maths
operates on: List    
operates on: Set
related zefop: variance
```

### Variance
```python
Calculates the variance of a given List / Set of numbers.

---- Examples ----
>>> [-1,0,1] | variance    # => 0.6666..

---- Signature ----
List[Int] -> Float
Set[Int] -> Float
List[Float] -> Float
Set[Float] -> Float

---- Tags ----
used for: maths
operates on: List    
operates on: Set
related zefop: mean
```

### Power
```python
Take the first argument to the power (exponential) of the second argument.

---- Examples ----
>>> 2 | power[8]    # => 256

---- Signature ----
(Int, Int) -> Int
(Float | Int, Float | Int) -> Float

---- Tags ----
used for: maths
operates on: Int    
operates on: Float    
related zefop: exponential
related zefop: multiply
```

### Exponential
```python
Take the first argument to the power of the second argument.

---- Examples ----
>>> 2 | exponential[8]    # => 256

---- Signature ----
(Float, Float) -> Float

---- Tags ----
used for: maths

related zefop: logarithm
related zefop: power
related zefop: multiply
```

### Logarithm
```python
Take the logarithm, optionally specify the base.
base = None is synonymous with base = 2.718281828459045...

---- Examples ----
>>> 10 | logarithm         # => 2.302585092994046
>>> 100 | logarithm[10]    # => 2

---- Signature ----
(Float, Float) -> Float

---- Tags ----
used for: maths    
related zefop: exponential
related zefop: power
related zefop: multiply
```

### Max
```python
None
```

### Min
```python
None
```

### MaxBy
```python
None
```

### MinBy
```python
None
```

### Equals
```python
Binary operator equivalent to calling "==", but can be chained.

---- Examples ----
>>> 42 | equals[42]     # => True
>>> 42 | Not[equals][41]     # => True
>>> equals('a', 'a')     # => True

---- Signature ----
(T, T) -> Bool

---- Tags ----
used for: logic

related zefop: Not
related zefop: greater_than
related zefop: less_than
```

### GreaterThan
```python
Binary operator equivalent to calling ">", but can be chained.

---- Examples ----
>>> 42 | greater_than[41]     # => True
>>> 42 | greater_than[42]     # => False

---- Signature ----
(T, T) -> Bool

---- Tags ----
used for: logic    
used for: maths    
related zefop: Not
related zefop: equals
related zefop: less_than
related zefop: greater_than_or_equal
```

### LessThan
```python
Binary operator equivalent to calling "<", but can be chained.

---- Examples ----
>>> 41 | less_than[42]     # => True
>>> 42 | less_than[42]     # => False

---- Signature ----
(T, T) -> Bool

---- Tags ----
used for: logic    
used for: maths    
related zefop: Not
related zefop: equals
related zefop: greater_than
related zefop: less_than_or_equal
```

### GreaterThanOrEqual
```python
Binary operator equivalent to calling ">=", but can be chained.

---- Examples ----
>>> 43 | greater_than_or_equal[42]     # => True
>>> 42 | greater_than_or_equal[42]     # => True

---- Signature ----
(T, T) -> Bool

---- Tags ----
used for: logic    
used for: maths    
related zefop: Not
related zefop: equals
related zefop: greater_than
related zefop: less_than_or_equal
```

### LessThanOrEqual
```python
Binary operator equivalent to calling ">=", but can be chained.

---- Examples ----
>>> 41 | less_than_or_equal[42]     # => True
>>> 42 | less_than_or_equal[42]     # => True

---- Signature ----
(T, T) -> Bool

---- Tags ----
used for: logic    
used for: maths    
related zefop: Not
related zefop: equals
related zefop: greater_than_or_equal
related zefop: less_than
```

### Not
```python
A logic combinator: takes a single predicate function 
(with any signature) and returns the negated predicate 
function with the same signature.

---- Examples ----
>>> 41 | Not[equals][42]     # => True

---- Signature ----
(T, T->Bool) -> Bool

---- Tags ----
used for: logic    
used for: function composition
operates on: predicate function
related zefop: Not
related zefop: Or
related zefop: And
related zefop: xor
```

### And
```python
This operator can be used in two ways:    

B) Multiary combinator to compose predicate functions.
   Given multiple predicate functions p_1, p_, ...p_m  with 
   signature S->Bool, the expression And[]
   a new predicate function of signature S->Bool is returned.
   Short circuiting is accounted for and the functions are
   evaluated in the order they are listed.

A) binary operator on boolean values

---- Examples ----
>>> 10 | And[greater_than[0]][less_than[42]]     # => True
>>> {'x': 42, 'b': 'yo'} | And[contains['x']][ get['b] | length | equals[2] ]

>>> [9,3,1,16] | map[And[greater_than[0]][less_than[5]]]     # => [False, True, True, False]

---- Signature ----
(T, T->Bool, T->Bool, ..., T->Bool ) -> Bool

---- Tags ----
used for: logic
used for: predicate
operates on: predicate function
related zefop: Or
related zefop: Not
related: Intersection
```

### Or
```python
This operator can be used in two ways:    

B) Multiary combinator to compose predicate functions.
   Given multiple predicate functions p_1, p_, ...p_m  with 
   signature S->Bool, the expression Or[]
   a new predicate function of signature S->Bool is returned.
   Short circuiting is accounted for and the functions are
   evaluated in the order they are listed.

A) binary operator on boolean values

---- Examples ----
>>> 100 | Or[greater_than[0]][less_than[42]]     # => False    
>>> [12,7,1] | map[Or[greater_than[10]][less_than[5]]]     # => [True, False, True]

---- Signature ----
(T, T->Bool, T->Bool, ..., T->Bool) -> Bool

---- Tags ----
used for: logic
used for: predicate
operates on: predicate function
related zefop: Or
related zefop: Not
related: Intersection
```

### Xor
```python
A logic combinator: takes two predicate functions
(with the same signature) and returns one predicate 
function with the same signature.

---- Examples ----
>>> 41 | xor[p1][p2]

---- Signature ----
(T, T->Bool, T->Bool) -> Bool

---- Tags ----
used for: logic    
used for: function composition
operates on: predicate function
related zefop: Not
related zefop: Or
related zefop: And
related zefop: xor
```

### Peel
```python
None
```

### Match
```python
Given an item and a list of Tuples[predicate, output]. The item is checked
sequentially on each predicate until one matches. If non-matches an exception is raised.

---- Examples ----
>>> -9 | match[
...     ({24, 42}, lambda x: f'a very special temperature'),
...     (Is[less_than[-10]], lambda x: f'it is a freezing {x} degrees'),
...     (Is[less_than[10]], lambda x: f'somewhat cold: {x} degrees'),
...     (Is[greater_than_or_equal[20]], lambda x: f'warm: {x}'),
...     (Any, lambda x: f'something else {x}'),
... ] | collect                             
'somewhat cold: -9 degrees'

---- Arguments ----
item: the incoming value
patterns: (T, T) -> Bool

---- Signature ----
(T, (T->Any)) -> T

---- Tags ----
- used for: control flow
- used for: logic
- used for: function application
```

### Sync
```python
Creates an effect to set the sync option on the graph. Defaults to enabling
sync (sync_state=True) but can be set to False to disable sync.

---- Examples ----
>>> g | sync | run
>>> g | sync[True] | run
>>> g | sync[False] | run

---- Signature ----
Graph -> Effect
(Graph, bool) -> Effect
```

### Tag
```python
Create an effect to add a tag to either a Graph or a RAE.

---- Examples ----
>>> g | tag["my_graph"] | run
>>> g2 | tag["my_graph"][True] | run
>>> z | tag["settings_node"] | g | run
>>> [z | tag["settings_node"]] | transact[g] | run

---- Arguments ----
x Graph / ZefRef: object to tag
tag str: the name of the tag to apply
force bool (=False): whether to allow stealing the tag from another graph or ZefRef.

---- Signature ----
(Graph, str, bool) -> Effect
(ZefRef, str, bool) -> LazyValue
```

### Untag
```python
Create an effect to remove a tag from either a Graph or a RAE

---- Examples ----
>>> g | untag["my_graph"] | run
>>> z | untag["settings_node"] | run

---- Signature ----
(Graph, str) -> Effect
(ZefRef, str) -> Effect
```

### ToClipboard
```python
A shortcut function to create an effect that will copy
an elementary type to the clipboard.

---- Examples ----
>>> 'hello' | to_clipboard                                  # returns an effect
>>> my_zef_func | to_clipboard | run                        # copy a single zef function to the clipboard
>>> g | now | all[ET.ZEF_Function] | to_clipboard | run     # copy all zef function on graph to clipboard

---- Signature ----
String                          -> Effect
Int                             -> Effect
Float                           -> Effect
Bool                            -> Effect
ZefRef[ET.ZEF_Function]         -> Effect
List[ZefRef[ET.ZEF_Function]]   -> Effect
```

### FromClipboard
```python
A shortcut function to create an effect that will request
the content of a clipboard to be copied
```

### TextArt
```python
convert a string to ascii art text
Todo: add flag to select comment style

---- Signature ----
String -> String
```

### ToJSON
```python
Serializes python types,zef types,ops, and custom types to a JSON dictionary

---- Examples ----
>>> zr | to_json | collect
>>> RT.A | to_json | collect

---- Signature ----
VT.Any -> VT.Dict
```

### FromJSON
```python
Deserializes a serialized object as a JSON dict back to the object.

---- Examples ----
>>> serialized_dict | from_json | collect

---- Signature ----
VT.Dict -> VT.Any
```

### ToYaml
```python
None
```

### FromYaml
```python
None
```

### ToToml
```python
None
```

### FromToml
```python
None
```

### ToCSV
```python
None
```

### FromCSV
```python
None
```

### ReadFile
```python
Reads the file at the given `fname` returning its content as bytes.

This operator produces an effect and must be passed to `run`. The output of
the effect will contain a "content" key with the file's content.

---- Examples ----
>>> "data.yaml" | read_file | run | get["content"] | from_yaml | collect

---- Signature ----
VT.String -> VT.Effect

---- Tags ----
- related zefop: load_file
- used for: file io
```

### LoadFile
```python
Reads the file at the given `fname` and parse its content based on the
file extension.

This operator produces an effect and must be passed to `run`. The output of
the effect will contain a "content" key with the transformed object.

---- Examples ----
>>> "data.yaml" | load_file | run | get["content"] | collect

---- Signature ----
VT.String -> VT.Effect

---- Tags ----
- related zefop: read_file
- used for: file io
```

### WriteFile
```python
The counterpart to `read_file`. Takes the given `content` and writes it to the file at the filename `fname`. The content is converted based on the extension of the file.

The options for content as described further in the `FX.LocalFile.Write` effect.

This operator doesn't do the writing itself, it only produces an effect
which must be passed to run.

---- Examples ----
>>> "Hello" | write_file["data.txt"] | run

---- Signature ----
(VT.Any, VT.String) -> VT.Effect
```

### SaveFile
```python
The counterpart to `load_file`. Takes the given `content` and writes it to the file at the filename `fname`. The content is converted based on the extension of the file.

The options for content as described further in the `FX.LocalFile.Save` effect.

This operator doesn't do the writing itself, it only produces an effect
which must be passed to run.

Settings is used for cases where we would need to pass additional flags to the underlying conversion.
An example is for csv, we can pass a dict {"na_values": True} to keep NA values in the Pandas DF.

---- Examples ----
>>> data_as_dict | save_file["data.yaml"] | run

---- Possible issues ---
data_as_dict | to_yaml | save_file["data.yaml"] | run
will create a yaml file containing a single string, which is unlikely to be
what you want.

---- Signature ----
(VT.Any, VT.String) -> VT.Effect
```

### PandasToGd
```python
Takes a pandas dataframe and a mapping Dict and returns a list of commands.

---- Signature ----
(VT.DataFrame,  VT.Dict) -> VT.List
```

### ToPipeline
```python
Given a list of operators, return one operator by constructing
an operator pipeline in that order.

---- Examples ----
>>> (nth[42], repeat, enumerate) | to_pipeline      # => nth[42] | repeat | enumerate

---- Tags ----
- used for: control flow
- operates on: ZefOp, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: inject
- related zefop: inject_list
- related zefop: absorbed
- related zefop: without_absorbed
- related zefop: reverse_args
- related zefop: bypass
```

### Inject
```python
Small helper function to inject the inflowing data via [...]

---- Examples ----
>>> 42 | inject[equals]         # => equals[42]

---- Tags ----
- used for: control flow
- operates on: ZefOp, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: inject_list
- related zefop: absorbed
- related zefop: without_absorbed
- related zefop: reverse_args
- related zefop: to_pipeline
```

### InjectList
```python
Small helper function to inject a list of inflowing data 
as multiple [...][...]...

---- Examples ----
>>> [pred1, pred2, pred3] | inject[And]         # => And[pred1][pred2][pred3]

---- Tags ----
- used for: control flow
- operates on: ZefOp, Value Types, Entity, Relation, AtomicEntity, ZefRef, EZefRef
- related zefop: inject
- related zefop: absorbed
- related zefop: without_absorbed
- related zefop: reverse_args
- related zefop: to_pipeline
```

### ZasciiToAsg
```python
Takes a zascii string and returns an asg dict.

---- Signature ----
(VT.String) -> VT.Dict

---- Examples ----
>>> s = """
>>>                   RT.RatingScore
>>>   ET.Dropdown1.0
>>>   """
>>> zascii_to_asg(s)


---- Tags ----
- used for: parsing ascii
- operates on: String
- related zefop: zascii_to_flatgraph
- related zefop: zascii_to_blueprint_fg
```

### ZasciiToFlatGraph
```python
Takes a zascii string representing a Graph and returns a FlatGraph containing all the RAEs 
appearing in the string.

---- Examples ----
>>> s = """
>>>                   RT.RatingScore
>>>   ET.Dropdown1.0
>>>   """
>>> zascii_to_flatgraph(s)
FlatGraph(
(temp_id_0002=>0)
(temp_id_0003=>1)
(temp_id_0004=>2)
-------
(0, ET.Dropdown, [2], None)
(1, AET.Float, [-2], None, 1.0)
(2, RT.RatingScore, [], None, 0, 1)
)

---- Signature ----
(VT.String) -> VT.FlatGraph

---- Tags ----
- used for: parsing ascii
- operates on: String
- related zefop: zascii_to_asg
- related zefop: zascii_to_blueprint_fg
```

### ZasciiToBlueprintFg
```python
Takes a zascii string representing a Graph Blueprint and returns a FlatGraph containing all the delegates 
appearing in the string.

---- Examples ----
>>> s = """
>>>                   RT.RatingScore
>>>   ET.DropdownAET.Int
>>>   """
>>> zascii_to_blueprint_fg(s)
FlatGraph(
(D1(ET.Dropdown)=>0)
(D1(AET.Int)=>1)
(D1({D1(ET.Dropdown)>RT.RatingScore>D1(AET.Int)})=>2)
-------
(0, D1(ET.Dropdown), [2], None)
(1, D1(AET.Int), [-2], None)
(2, D1({D1(ET.Dropdown)>RT.RatingScore>D1(AET.Int)}), [], None, 0, 1)
)    

---- Signature ----
(VT.String) -> VT.FlatGraph

---- Tags ----
- used for: parsing ascii
- operates on: String
- related zefop: zascii_to_asg
- related zefop: zascii_to_flatgraph
```

### ReplaceAt
```python
Given a list replace element at an index with new_el.
Given a string return a new string with element at index replaced with new_el.


---- Examples ----
>>> ['a','b','c'] | replace_at[1]['x']    # => ['a','x','c']
>>> 'hello' | replace_at[1]['a'] | c      # 'hallo'

---- Signature ----
(VT.String, VT.Int, VT.String) -> VT.String
(VT.List, VT.Int, VT.Any) -> VT.List

---- Tags ----
- related zefop: replace
- used for: list manipulation
- operates on: String
- operates on: List
```

### RandomPick
```python
Given a list, tuple, string: returns a random item from that iterable.
```

### PadLeft
```python
Pads a string to a specified length by inserting
the pad_element on the left.
If the input string is longer than the specified
length, the original string is returned.
The pad_element is optional, with ' ' being the
default.

---- Examples ----
>>> 'hi' | pad_left[5]['.']      # => '...hi'
>>> 'hi' | pad_left[5]           # => '   hi'

---- Signature ----
String -> String

---- Tags ----
operates on: String
used for: string manipulation
related zefop: pad_right
related zefop: pad_center
related zefop: slice
```

### PadRight
```python
Pads a string to a specified length by inserting
the pad_element on the right.
If the input string is longer than the specified
length, the original string is returned.
The pad_element is optional, with ' ' being the
default.

---- Examples ----
>>> 'hi' | pad_right[5]['.']      # => 'hi...'
>>> 'hi' | pad_right[5]           # => 'hi   '

---- Signature ----
String -> String

---- Tags ----
operates on: String
used for: string manipulation
related zefop: pad_left
related zefop: pad_center
related zefop: slice
```

### PadCenter
```python
Pads a string to a specified length by inserting
the pad_element on both sides, equally.
If an odd number of pad_elements must be distributed,
one more is added to the left.
If the input string is longer than the specified
length, the original string is returned.
The pad_element is optional, with ' ' being the
default.

---- Examples ----
>>> 'hi' | pad_center[5]['.']      # => '..hi.'
>>> 'hi' | pad_center[5]           # => '  hi '

---- Signature ----
String -> String

---- Tags ----
operates on: String
used for: string manipulation
related zefop: pad_left
related zefop: pad_right
related zefop: slice
```

### Floor
```python
The mathematical floor function.
Rounds down to the next smallest integer.

---- Examples ----
>>> 5.1 | floor      # => 5
>>> 5.9 | floor      # => 5
>>> 5.0 | floor      # => 5

---- Signature ----
Float -> Int
Int -> Int

---- Tags ----
operates on: Float
used for: maths
related zefop: ceil
related zefop: round
```

### Ceil
```python
The mathematical ceil function.
Rounds down to the next biggest integer.

---- Examples ----
>>> 5.1 | ceil      # => 6
>>> 5.9 | ceil      # => 6
>>> 5.0 | ceil      # => 5

---- Signature ----
Float -> Int
Int -> Int

---- Tags ----
operates on: Float
used for: maths
related zefop: floor
related zefop: round
```

### Round
```python
The mathematical round function.
Rounds down to the next integer.

---- Examples ----
>>> 5.1 | round      # => 5
>>> 5.9 | round      # => 6
>>> 5.5 | round      # => 5
>>> 5.0 | round      # => 5

---- Signature ----
Float -> Int
Int -> Int

---- Tags ----
operates on: Float
used for: maths
related zefop: floor
related zefop: ceil
```

### IsAlpha
```python
Given a string return if it is only composed of Alphabet characters
```

### IsNumeric
```python
Given a string, determine if all characters are numeric, i.e. string
representations of integers.

---- Examples ----
>>> 'a' | is_numeric          # => False
>>> '4' | is_numeric          # => True
>>> '42' | is_numeric         # => True
>>> '42.6' | is_numeric       # => False

---- Signature ----
String -> Bool

---- Tags ----
- related zefop: is_alpha
- related zefop: is_alpha_numeric
- operates on: String
- used for: predicate function    
```

### IsAlphaNumeric
```python
Given a string, determine if all characters are numeric or 
alphabetical letters. Any special symbols or characters 
would cause this function to return False.

---- Examples ----
>>> 'a' | is_alpha_numeric          # => True
>>> '4' | is_alpha_numeric          # => True
>>> '42abc' | is_alpha_numeric      # => True
>>> 'hello!' | is_alpha_numeric     # => False
>>> 'good morning' | is_alpha_numeric     # => False


---- Signature ----
String -> Bool

---- Tags ----
- related zefop: is_alpha
- related zefop: is_numeric
- operates on: String
- used for: predicate function    
```

### ToUpperCase
```python
Given a string, capitalize each character.

---- Examples ----
>>> 'aBc' | to_upper_case          # => 'ABC'

---- Signature ----
VT.String -> VT.String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToLowerCase
```python
Given a string, convert each character to lower case.

---- Examples ----
>>> 'aBc' | to_upper_case          # => 'abc'

---- Signature ----
VT.String -> VT.String


---- Tags ----
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToPascalCase
```python
Convert a string to PascalCase style. Uses the caseconverter module.

This is intended for use in producing variable names. It is also useful for
generating token (e.g. `ET` or `RT`) names.

---- Examples ----
>>> 'person_name' | to_pascal_case   # => "PersonName"
>>> 'jsObject' | to_pascal_case      # => "JsObject"
>>> 'external. data-with  UNUSUAL@characters' | to_pascal_case   # => "ExternalDataWithUnusualcharacters"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToCamelCase
```python
Convert a string to camelCase style. Uses the caseconverter module.

This is intended for use in producing variable names.

---- Examples ----
>>> 'person_name' | to_camel_case   # => "personName"
>>> 'TokenName' | to_camel_case    # => "tokenName"
>>> 'external. data-with  UNUSUAL@characters' | to_camel_case   # => "externalDataWithUnusualcharacters"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToKebabCase
```python
Convert a string to kebab-case style. Uses the caseconverter module.

This is intended for use in producing variable names.

---- Examples ----
>>> 'person_name' | to_kebab_case   # => "person-name"
>>> 'TokenName' | to_kebab_case    # => "token-name"
>>> 'external. data-with  UNUSUAL@characters' | to_kebab_case   # => "external-data-with-unusualcharacters"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_snake_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToSnakeCase
```python
Convert a string to snake_case style. Uses the caseconverter module.

This is intended for use in producing variable names.

---- Examples ----
>>> 'yaml-keyword' | to_snake_case   # => "yaml_keyword"
>>> 'TokenName' | to_snake_case    # => "token_name"
>>> 'external. data-with  UNUSUAL@characters' | to_snake_case   # => "external_data_with_unusualcharacters"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_screaming_snake_case
- operates on: String
- used for: string manipulation
```

### ToScreamingSnakeCase
```python
Convert a string to SCREAMING_SNAKE_CASE style. Uses the caseconverter module.

This is intended for use in producing variable names.

---- Examples ----
>>> 'yaml-keyword' | to_screaming_snake_case   # => "YAML_KEYWORD"
>>> 'TokenName' | to_screaming_snake_case    # => "TOKEN_NAME"
>>> 'external. data-with  UNUSUAL@characters' | to_screaming_snake_case   # => "EXTERNAL_DATA_WITH_UNUSUALCHARACTERS"

---- Signature ----
String -> String

---- Tags ----
- related zefop: to_lower_case
- related zefop: to_upper_case
- related zefop: to_pascal_case
- related zefop: to_camel_case
- related zefop: to_kebab_case
- related zefop: to_snake_case
- operates on: String
- used for: string manipulation
```

### Unpack
```python
used to wrap an zefop or a function. If the function
takes multiple arguments, it is converted into a function
that takes one tuple or list as a single argument.
This list is unpacked into the function arguments.

---- Signature ----
(Tuple[T1, T2, ...], Func[T1, T2, ...][T] ) -> T

---- Examples ----
>>> (42, 10) | unpack[subtract]      # => 32


---- Tags ----
used for: control flow
related zefop: reverse_args
```

### IndexesOf
```python
Given a list, returns the indexes of the elements which are of
a specified logic type / set.

---- Signature ----
(List[Any], ValueType) -> List[Int]

---- Examples ----
>>> me = ["foo", 5,"bar", "baz", 'bar'] | indexes_of[SetOf["bar",]] | c  # => [2, 4]

---- Tags ----
operates on: List
```

### GraphSliceIndex
```python
Returns the index of a GraphSlice as an Int. 

Historical note: the GraphSlice data structure itself replaces 
what was previously the TimeSlice.

Historical note 2: There was initial confusion in conflating the 
transactions themselves with time slices / graph slices.
These are distinct concepts: TXs are sets of changes, 
i.e. events: "what happened?"

GraphSlices are states: "What is?" They are also known as 
"reference frames"

---- Examples ----
>>> my_graph_slice | graph_slice_index

---- Signature ----
(GraphSlice, ) -> Int
```

### MakeRequest
```python
None
```

### Blake3
```python
Cryptographic hash function.
Can be applied to strings and Bytes.

---- Examples ----
>>> 'hello' | blake3    
>>> b'hello' | blake3    

---- Signature ----
String -> String
Bytes -> String

---- Tags ----
- used for: Cryptography
- used for: Hashing
- operates on: String
- operates on: Bytes
```

### ValueHash
```python
Cryptographic hash function using blake3 
for non-str/bytes values including Zef Values.

---- Examples ----
>>> 5 | value_hash    
>>> g | value_hash    

---- Signature ----
Any -> String

---- Tags ----
- used for: Cryptography
- used for: Hashing
- operates on: Values
- operates on: Any
```

### ToZefList
```python
None
```

### Transact
```python
None
```

### Function
```python
func_repr is of form (int, any)
where the first integer encodes how the function is
represented in the ZefOp:
-------- representation types -------
0) Abstract Entity
1) captured python lambda or local function
```

### On
```python
Create an event stream based on the event type declared 
in the parameters. This function itself is impure! It sets 
up a concrete stream and a callback listening for events 
on a graph.

The returned Streams do not contain dicts, but the events
expressed as ZefOps. Why? The Zef query syntax is built
upon predicate logic and the events in the stream are in 
this very language and represent positive clauses, i.e. 
state facts about what happened. For example, 
"instantiated[z1]" is an assertion / account of the fact
that the entity referenced by z1 occurred. The reference
frame of z1 contains the time at which the logical thread
of that frame learned about that fact.

This function is pure, it returns an abstract stream. The
program state is only changed and all is hooked up on the
dataflow graph once an impure functions subscribes at 
the very end.

---- Examples ----
>>> g | on[assigned[AET.String]]                    # assigned[z3]['hello!']      c.f. with action: assign[z3]['hello!']
>>> g | on[terminated[z2]]                          # terminated[z2], followed by completion_event
>>> g | on[instantiated[ET.Foo]]                    # instantiated[z5]
 
# listening for new relations
# old syntax:  zz | subscribe[on_instantiation[outgoing][RT.Foo]][my_callback]       old syntax
>>> g | on[ instantiated[(zz, RT.Foo, Z)] ]         # Z matches on anything, i.e. takes on role of "_"

>>> One can also add more precise requirements
>>> g | on[ instantiated[(zz, RT.Foo, ET.Bar)] ]    # an element "instantiated[z_rel]" is pushed into the stream. Instances are represented by a single ZefRef, types by a triple for relations
>>> g | on[ terminated[(zz, RT.Foo, Z)] ]

>>> g | on[terminated[z_rel]]

---- Signature ----
(Graph, ZefOp[ValueAssigned]) -> Stream[ZefOp[ValueAssigned[ZefRef][Any]]]
(Graph, ZefOp[Instantiated]) -> Stream[ZefOp[Instantiated[ZefRef]]]
(Graph, ZefOp[Terminated]) -> Stream[ZefOp[Terminated[ZefRef]]]

...
```

### Range
```python
Introduce a separate operator from Python's range.

1)  The lazy output value type should be uniform for other
zefops to deal with. `range` does not return a general Python
generator, but a special range object. We don't want to  make
all other zefops that can operate on a lazy List[Int] to special
case range.

2) we want the ability to pipe the boundary values into `Range`.
Range can take a single int or a pair of ints and returns a lazy
List[Int].

3) In contrast to Python's builtin `range`, Zef's `Range` can
be called with infinity as an upper bound.

---- Signature ----
Int -> List[Int]
(Int, Int) -> List[Int]

---- Examples ----
>>> 4 | Range         # => [0,1,2,3]   # but as a generator
>>> (2, 5) | Range    # => [2,3,4]
>>> Range(4)          # => [0,1,2,3]   # not lazy! The parentheses trigger evaluation for ZefOps!
>>> infinity | Range  # => [0,1,2,3, ... # lazy and infinitely long
>>> (4, infinity) | Range  # => [4,5,6, ... # lazy and infinitely long

---- Gotchas ----
- calling with parentheses triggers evaluation. If this is 
  called for an infinite lazy sequence, the evaluation will not terminate.

---- Tags ----
- used for: List manipulation
```

### ZstandardCompress
```python
Compress a Bytes value using ZStandard.
The compression level can be specified optionally.

---- Example ----
>>> 'hello' | to_bytes | zstandard_compress

---- Signature ----
Bytes -> Bytes

---- Tags ----
used for: data compression    
operates on: Bytes
related zefop: zstandard_compress
```

### ZstandardDecompress
```python
Decompress a Bytes value using ZStandard.

---- Example ----
>>> 'hello' | to_bytes | zstandard_compress | zstandard_decompress

---- Signature ----
Bytes -> Bytes

---- Tags ----
used for: data compression    
operates on: Bytes
related zefop: zstandard_decompress
```

### ToBytes
```python
Convert a string to a ValueType Bytes using utf8 encoding.
Python bytes are wrapped and Bytes are forwarded.

---- Example ----
>>> 'hello' | bytes_to_base64string     # equivalent to Bytes(b'hello')

---- Signature ----
String | Bytes -> Bytes

---- Tags ----
used for: type conversion
operates on: String
```

### Utf8bytesToString
```python
Convert a Byes value that is a utf8 encoded string,
return the string. Not all bytes values are valid utf8.


---- Example ----
>>> 'hello' | to_bytes | utf8bytes_to_string     # => 'hello'

---- Signature ----
Bytes -> String | Error

---- Tags ----
used for: type conversion
operates on: Bytes
```

### Base64stringToBytes
```python
Convert data that is in a valid base64 encoding as a string to bytes.
Not all strings are valid base64 encoded strings.
Returns the decoded Bytes object

---- Example ----
>>> 'hello' | bytes_to_base64string

---- Signature ----
String | Bytes -> Bytes

---- Tags ----
used for: type conversion
operates on: String
```

### BytesToBase64string
```python
Convert any bytes object into a base64 encoded string.

---- Example ----
>>> b'hello' | bytes_to_base64string

---- Signature ----
Bytes -> String

---- Tags ----
used for: type conversion
operates on: Bytes
```

### IsBetween
```python
Checks whether a specified value lies within the 
specified range for some orderable data type.
Like the SQL counterpart, this operator is INCLUSIVE.

---- Examples ----
>>> 5 | is_between[1][9]     # => True
>>> 42 | is_between[1][9]    # => False
>>> 9 | is_between[1][9]     # => True

---- Signature ----
Tuple[List[T], T, T] -> Bool

---- Tags ----
used for: logic
used for: maths
operates on: List[Int]
operates on: List[Float]
operates on: List[QuantityInt]
operates on: List[QuantityFloat]
```

### If
```python
Dispatches to one of two provided functions based on the boolean 
result of the predicate function wrapped as a logic type, given
the input value.
The input value into the zefop is used by the predicate and 
forwarded to the relevant case function.

---- Examples ----
>>> Evens = Is[modulo[2] | equals[0]]
>>> 4 | If[ Evens ][add[1]][add[2]]            # => 5

---- Signature ----
((T->Bool), (T->T1), (T->T2)) -> Union[T1, T2]

---- Tags ----
- used for: control flow
- used for: logic
- related zefop: group_by
- related zefop: match
- related zefop: filter
```

### Field
```python
None
```

### Fields
```python
None
```

### Apply
```python
Very similar to func to apply a function
to an input argument.
In addition, a tuple of functions (f1,..,.fn) can 
be specified and the output is is the tuple of
the individual output values.
Note that this procedure is distinct from map, as
it acts on the single flow input argument once.

---- Signature ----
(T,  (T->T2) ) -> T2    # if f is a single function
(T, List[(T->T2)] ) -> List[T2]

---- Examples ----
>>> 40 | apply[
...    add[1],
...    add[2],
...    String,
... ]
(41, 42, '40')

---- Tags ----
- related zefop: map
- related zefop: apply_functions
- related zefop: func
- related zefop: call
- used for: control flow
- used for: function application
```

### SplitOnNext
```python
Split a List or a string at one point only

---- Examples ----
>>> before, after = split_on_next('good morning, good afternoon, good night', ', ')     # => ['good morning', 'good afternoon, good night']
>>> [1,2,3,4,5,3,8] | split_on_next[3]    # => (1,2), (4, 5, 3, 8)

---- Signature ----
(String, String) -> String
(List[T], T) -> List[T]

---- Tags ----
- related zefop: split
- related zefop: split_if
- related zefop: chunk
- operates on: List
- operates on: String
- used for: list manipulation
- used for: string manipulation
```

### Examples
```python
Returns the examples portion of a docstring as a list of tuples mapping
example string to a possible output string.

It is able to handle multiline result, but not multine examples. This
will be later improved.

---- Examples ----
>>> examples(to_snake_case)
[("'yaml-keyword' | to_snake_case", '"yaml_keyword"'),
("'TokenName' | to_snake_case", '"token_name"'),
("'external. data-with  UNUSUAL@characters' | to_snake_case",
'"external_data_with_unusualcharacters"')]

---- Signature ----
(ZefOp) -> List[Tuple[String | Nil]]

---- Tags ----
- related zefop: tags
- related zefop: signature
- related zefop: related_ops
- related zefop: operates_on
- related zefop: used_for
- operates on: ZefOp
- used for: op usage
```

### Signature
```python
Given the signature portion of a docstring is valid, returns back a List of Strings.

---- Examples ----
>>> signature(apply)
['(T,  (T->T2) ) -> T2', '(T, List[(T->T2)] ) -> List[T2]']

>>> signature(schema)
['(Graph, Bool) -> List[EZefRef]', '(GraphSlice, Bool) -> List[ZefRef]']

---- Signature ----
(ZefOp) -> List[String]

---- Tags ----
- related zefop: tags
- related zefop: examples
- related zefop: related_ops
- related zefop: operates_on
- related zefop: used_for
- operates on: ZefOp
- used for: op usage
```

### Tags
```python
Returns the tags portion of a docstring as a list of list of strings.

---- Examples ----
>>> tags(map)
[['used for', 'control flow'],
['used for', 'function application'],
['related zefop', 'apply_functions']]

---- Signature ----
(ZefOp) -> List[String]

---- Tags ----
- related zefop: signature
- related zefop: examples
- related zefop: related_ops
- related zefop: operates_on
- related zefop: used_for
- operates on: ZefOp
- used for: op usage
```

### RelatedOps
```python
Extracts the related ops from the tags portion of the docstring of the op.
It returns back a list of ZefOp. It also discards invalid ZefOps.

---- Examples ----
>>> related_ops(to_snake_case)
[to_lower_case, to_upper_case, to_pascal_case, to_camel_case, to_kebab_case, to_screaming_snake_case]

---- Signature ----
(ZefOp) -> List[ZefOp]

---- Tags ----
- related zefop: signature
- related zefop: examples
- related zefop: tags
- related zefop: operates_on
- related zefop: used_for
- operates on: ZefOp
- used for: op usage
```

### OperatesOn
```python
Extracts the operates on Types from the tags portion of the docstring of the op.
It returns back a list of ValueTypes. It also discards invalid ValueTypes.

---- Examples ----
>>> operates_on(blake3)
[String, Bytes]

---- Signature ----
(ZefOp) -> List[ValueType]

---- Tags ----
- related zefop: signature
- related zefop: examples
- related zefop: tags
- related zefop: related_ops
- related zefop: used_for
- operates on: ZefOp
- used for: op usage
```

### UsedFor
```python
Extracts the used for from the tags portion of the docstring of the op.

---- Examples ----
>>> used_for(append)   # => ["list manipulation", "string manipulation"]

---- Signature ----
(ZefOp) -> List[String]

---- Tags ----
- related zefop: signature
- related zefop: examples
- related zefop: tags
- related zefop: related_ops
- related zefop: used_for
- operates on: ZefOp
- used for: op usage
```

### Gather
```python
An operator that given a launch point on a graph, gathers up 
a subgraph by traversing based on a rules pattern that is specified.
There are two main modes of usage: 

---------------- A: Explicit Rules -----------------
Giving an explicit rule set:
>>> rules = [
>>>     (Z[ET.A], RT.R1, ET.B),        # from source
>>>     (Z[Any], RT.R2, AET.String),    
>>>     (ET.Bar, RT.R2, Z[ET.Foo]),    # from target moving in the opposite direction of the relation
>>> ]
then 
>>> z1 | gather[rules]
will iteratively traverse the graph until there is nothing more to be collected.
What do the rules specify in this case? For example, the first rule (ET.A, RT.R1, ET.B)
being part of 'from_source' mean that if one were to stand on a node of type "ET.A" as a source,
with an outgoing relation of type "RT.R1" which leads to a "ET.B", then take that step
and include both the edge and the "ET.B" in the gathered set.

---------------- B: Implicit Rules -----------------
For certain entity types, predefined rule sets are associated.
B1) For ET.ZEF_Function, a rule set to gather all things related to that function is predefined.
Future: Also for ET.ZEF_EffectModule, ET.ZEF_Op
```

### Privileges
```python
None
```

### Config
```python
None
```

### TakeTransactorRole
```python
None
```

### ReleaseTransactorRole
```python
None
```

### HaveTransactorRole
```python
None
```

